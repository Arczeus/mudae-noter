<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mudae Note Manager</title>
    <link rel="icon" type="image/png" href="https://cdn.imgchest.com/files/59a3ca5bc2d6.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .container {
            max-width: 1610px;
            background: #13131a;
            border-radius: 15px;
            padding: 30px;
            border: 1px solid #1f1f2e;
        }

        .header-row {
            margin-bottom: 25px;
        }

        h1 {
            color: #a78bfa;
            margin-bottom: 10px;
            font-size: 2em;
        }

        h2 {
            color: #a78bfa;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #9ca3af;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .instructions {
            margin-top: 10px;
            font-size: 0.8em;
            color: #6b7280;
            line-height: 1.6;
        }

        .quick-notes {
            background: #13131a;
            border-radius: 15px;
            padding: 20px;
            width: 280px;
            border: 1px solid #1f1f2e;
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 40px);
        }

        .quick-notes-title {
            font-size: 1.1em;
            font-weight: 700;
            color: #a78bfa;
            margin-bottom: 15px;
        }

        .quick-notes-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
            overflow-y: auto;
            scrollbar-gutter: stable;
            padding-right: 5px;
        }

        .quick-note {
            background: #1a1a24;
            border: 2px solid #7c3aed;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 5px;
            color: #e5e7eb;
        }

        .quick-note:hover {
            background: #7c3aed;
            color: white;
        }

        .quick-note-remove {
            font-size: 1.4em;
            margin-left: auto;
            opacity: 0.6;
            padding: 0 8px;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quick-note-remove:hover {
            opacity: 1;
            background-color: #b91c1c;
            color: white;
        }

        .add-note-container {
            display: flex;
            gap: 8px;
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid #2a2a3a;
            min-width: 0;
        }

        .add-note-input {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #2a2a3a;
            border-radius: 5px;
            font-size: 0.9em;
            background: #0a0a0f;
            color: #e5e7eb;
            min-width: 0;
        }

        .hidden-char {
            display: none !important;
        }

        .add-note-btn {
            padding: 6px 15px;
            font-size: 0.9em;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        c .add-note-btn:hover {
            background-color: #6d28d9;
        }

        label {
            display: block;
            font-weight: 600;
            color: #e5e7eb;
            margin-bottom: 8px;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 2px solid #2a2a3a;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            background: #0a0a0f;
            color: #e5e7eb;
        }

        textarea:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .filter-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        button {
            background: #7c3aed;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        button:hover {
            background: #6d28d9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
        }

        button:disabled {
            background: #4b5563;
            cursor: not-allowed;
            transform: none;
        }

        button.active {
            background: #34c965;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .controls-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 30px;
            align-items: stretch;
        }

        .actions-panel {
            display: flex;
            flex-direction: column;
        }

        .actions-panel textarea {
            flex-grow: 1;
            min-height: 200px;
            resize: vertical;
        }

        .actions-panel,
        .options-panel {
            background: #1a1a24;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #2a2a3a;
        }

        .options-panel {
            grid-column: 2;
            grid-row: 1;
        }

        .options-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 1px solid #2a2a3a;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #e5e7eb;
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .button-group label {
            margin-bottom: 0;
            font-size: 0.9em;
            color: #9ca3af;
            margin-right: 5px;
        }

        .button-group button {
            margin-right: 0;
            padding: 8px 15px;
            font-size: 0.9em;
            transform: none;
            box-shadow: none;
        }

        .button-group button:not(.active) {
            background: #2a2a3a;
            color: #9ca3af;
        }

        .button-group button:hover {
            transform: translateY(-1px);
        }

        .button-group button.active {
            background: #7c3aed;
            color: white;
            box-shadow: 0 4px 10px rgba(124, 58, 237, 0.3);
        }

        .main-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .btn-primary {
            background: #7c3aed;
        }

        .btn-primary:hover {
            background: #6d28d9;
        }

        .btn-secondary {
            background: #4b5563;
        }

        .btn-secondary:hover {
            background: #374151;
        }

        .btn-tertiary {
            background: #2a2a3a;
            padding: 6px 12px;
            font-size: 0.9em;
        }

        #filter-section {
            margin-top: 0;
            padding: 0;
            background: transparent;
            border: none;
        }

        .stats-panel {
            background: transparent;
            border: none;
            padding: 0;
            margin-top: auto;
        }

        .stats {
            display: flex;
            gap: 20px;
            padding-top: 15px;
        }

        .filter-controls-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            gap: 5px;
        }

        .series-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .series-card {
            background: #1a1a24;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2a2a3a;
        }

        .series-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .series-title {
            font-weight: 600;
            color: #e5e7eb;
            font-size: 0.95em;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .series-toggle-btn {
            background: #7c3aed;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .series-toggle-btn:hover {
            transform: translateY(-2px);
        }

        .series-toggle-btn.disabled {
            background: #dc2626;
        }

        .series-toggle-btn.disabled:hover {
            background: #b91c1c;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
        }

        .series-count {
            color: #9ca3af;
            font-size: 0.85em;
        }

        .note-input {
            width: 100%;
            padding: 8px;
            border: 2px solid #2a2a3a;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.9em;
            background: #0a0a0f;
            color: #e5e7eb;
        }

        .note-input:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .characters-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .character-card {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            border-radius: 8px;
            overflow: hidden;
            width: 135px;
        }

        .character-card img {
            width: 135px;
            height: 210px;
            object-fit: cover;
            display: block;
        }

        .character-card:hover {
            transform: scale(1.05);
            border-color: #a78bfa !important;
        }

        .character-card.excluded {
            filter: opacity(0.5);
        }

        .character-card.excluded img {
            filter: grayscale(100%);
        }

        .character-card.permanently-disabled::after {
            content: '🚫';
            position: absolute;
            top: 105px;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7em;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 10px black;
            pointer-events: none;
        }

        .character-info {
            background: #0a0a0f;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .character-name {
            color: #e5e7eb;
            font-size: 0.7em;
            text-align: center;
            word-break: break-word;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .character-stats {
            display: flex;
            justify-content: space-around;
            gap: 8px;
            font-size: 0.65em;
        }

        .stat-badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .stat-badge-label {
            color: #9ca3af;
            font-size: 0.9em;
        }

        .stat-badge-value {
            color: #a78bfa;
            font-weight: 700;
        }

        .character-rank-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(10, 10, 15, 0.8);
            color: #a78bfa;
            font-weight: 700;
            font-size: 0.9em;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 10;
            cursor: pointer;
            border: 1px solid #a78bfa;
        }

        .rank-input {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 40px;
            z-index: 10;
            text-align: center;
            border: 1px solid #7c3aed;
            background: #1a1a24;
            color: #e5e7eb;
            border-radius: 4px;
        }

        .commands-section {
            margin-top: 30px;
            padding: 20px;
            background: #1a1a24;
            border-radius: 10px;
            border: 1px solid #2a2a3a;
        }

        .command-item {
            background: #13131a;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #7c3aed;
        }

        .command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .command-series {
            font-weight: 600;
            color: #e5e7eb;
        }

        .command-text {
            background: #0a0a0f;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            margin-bottom: 10px;
            color: #d1d5db;
            border: 1px solid #2a2a3a;
        }

        .copy-btn {
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .stat-item {
            flex: 1;
        }

        .stat-label {
            font-size: 0.85em;
            color: #9ca3af;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            color: #a78bfa;
        }

        .error-message {
            background: #7f1d1d;
            color: #fecaca;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #dc2626;
            margin-top: 15px;
        }

        .success-message {
            background: #064e3b;
            color: #6ee7b7;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #10b981;
            margin-top: 15px;
        }

        .empty-message {
            display: none;
        }

        .card-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #13131a;
            border-radius: 8px;
        }

        .controls-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .sort-buttons button {
            background: #2a2a3a;
            color: #9ca3af;
            border: 1px solid transparent;
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sort-buttons button:hover {
            background: #7c3aed;
            color: white;
            transform: translateY(-1px);
        }

        .sort-buttons button.active {
            background: #7c3aed;
            color: white;
        }

        .note-applicator .apply-btn {
            padding: 8px 15px;
            font-size: 0.8em;
            white-space: nowrap;
            background-color: #6d28d9;
            flex-shrink: 0;
        }

        .note-applicator .apply-btn:hover {
            background-color: #7c3aed;
        }

        .footer {
            text-align: center;
            padding: 1%;
            color: #6b7280;
            font-size: 0.85em;
            border-top: 1px solid #2a2a3a;
        }

        .footer-contact {
            margin-top: 10px;
            font-size: 0.9em;
        }

        .footer-contact strong {
            color: #a78bfa;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header-row">
            <h1>Mudae Note Manager</h1>
            <p class="subtitle">Parse your $mmasi-[y+][k][c+][x+][n] (brackets are optional) output and create note
                commands for
                your characters</p>
            <div class="instructions">
                <div>• Click characters to disable</div>
                <div>• Click "Disable All" to toggle entire series</div>
                <div>• Add notes to group characters</div>
                <div>• You can also use this to generate $ec or other commands</div>
            </div>
        </div>

        <div class="input-section">
            <div class="controls-container">
                <div class="actions-panel">
                    <label for="input">Paste your $mmasi output here:</label>
                    <textarea id="input"
                        placeholder="Dungeon Meshi - 4/10&#10;Laios Touden 5680 ka - https://mudae.net/uploads/dm1.png&#10;Marcille Donato | Elf ✨ · :goldkey: (3) (#fde2e2) 7250 ka - https://mudae.net/uploads/dm2.png&#10;Chilchuck Tims · :silverkey: (1) 2800 ka - https://mudae.net/uploads/dm3.png&#10;Izutsumi | KIBTY!! :3 (#6f4e37) 3100 ka - https://mudae.net/uploads/dm4.png&#10;&#10;Vocaloid - 3/25&#10;Hatsune Miku 🚫 9980 ka - https://mudae.net/uploads/v1.png&#10;Kagamine Rin · :goldkey: (2) (#ffcc00) 6100 ka - https://mudae.net/uploads/v2.png&#10;KAITO 4300 ka - https://mudae.net/uploads/v3.png"></textarea>
                    <div class="main-buttons">
                        <button onclick="parseInput()" class="btn-primary">Parse Input</button>
                        <button onclick="clearAll()" class="btn-primary">Clear All</button>
                        <button onclick="generateCommands()" id="generateBtn" disabled>Generate Commands</button>
                        <button onclick="scrollToCommands()" id="goToCommandsBtn" style="display: none;">Go to Commands
                            ↓</button>
                    </div>
                    <div id="stats" class="stats-panel"></div>

                </div>

                <div class="options-panel">
                    <h2>Options</h2>

                    <div class="control-group">
                        <h3>Grouping</h3>
                        <div class="button-group">
                            <button onclick="setGrouping('nogroup')" id="group-nogroup-btn">None</button>
                            <button onclick="setGrouping('series')" id="group-series-btn" class="active">Series</button>
                            <button onclick="setGrouping('note')" id="group-note-btn">Note</button>
                            <button onclick="setGrouping('keys')" id="group-keys-btn">Keys</button>
                            <button onclick="setGrouping('kakera')" id="group-kakera-btn">Kakera</button>
                        </div>
                        <div id="kakera-range-container" style="display: none; margin-top: 10px;">
                            <label for="kakera-range-input">Range Size:</label>
                            <input type="number" id="kakera-range-input" value="1000" class="add-note-input"
                                style="width: 100px;">
                            <button onclick="displaySeries()" class="btn-tertiary">Apply</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Sorting & Display</h3>
                        <div class="button-group">
                            <label>Sort Groups:</label>
                            <button onclick="sortGroups('alpha')" id="sort-alpha-btn" class="active">A-Z</button>
                            <button onclick="sortGroups('count')" id="sort-count-btn">Count</button>
                        </div>
                        <div class="button-group">
                            <label>Ranking:</label>
                            <button onclick="toggleRanking(true)" id="ranking-on-btn" class="active">On</button>
                            <button onclick="toggleRanking(false)" id="ranking-off-btn">Off</button>
                        </div>
                        <div class="button-group">
                            <label>Deselected:</label>
                            <button onclick="toggleDeselectedVisibility(true)" id="deselected-show-btn"
                                class="active">Show</button>
                            <button onclick="toggleDeselectedVisibility(false)" id="deselected-hide-btn">Hide</button>
                        </div>
                        <div class="button-group">
                            <label>Columns:</label>
                            <button onclick="changeGridColumns(1)" id="grid-btn-1">1</button>
                            <button onclick="changeGridColumns(2)" id="grid-btn-2">2</button>
                            <button onclick="changeGridColumns(3)" id="grid-btn-3" class="active">3</button>
                            <button onclick="changeGridColumns(4)" id="grid-btn-4">4</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Bulk Actions</h3>
                        <div class="button-group">
                            <button onclick="selectAllCharacters()">Select All</button>
                            <button onclick="deselectAllCharacters()">Deselect All</button>
                        </div>
                    </div>

                    <div class="control-group" id="filter-section">
                        <h3>Filter Characters</h3>
                        <div class="filter-controls-container">
                            <div class="filter-group">
                                <div class="filter-control">
                                    <label for="min-kakera">Min Ka</label>
                                    <input type="number" id="min-kakera" placeholder="0" class="add-note-input">
                                </div>
                                <div class="filter-control">
                                    <label for="max-kakera">Max Ka</label>
                                    <input type="number" id="max-kakera" placeholder="any" class="add-note-input">
                                </div>
                            </div>
                            <div class="filter-group">
                                <div class="filter-control">
                                    <label for="min-keys">Min Keys</label>
                                    <input type="number" id="min-keys" placeholder="0" class="add-note-input">
                                </div>
                                <div class="filter-control">
                                    <label for="max-keys">Max Keys</label>
                                    <input type="number" id="max-keys" placeholder="any" class="add-note-input">
                                </div>
                            </div>
                            <div>
                                <button onclick="applyFilter()" class="btn-primary">Apply Filter</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="message"></div>
        <div id="seriesGrid" class="series-grid"></div>
        <div id="commands"></div>
        <div class="footer">
            <div class="footer-contact">
                Questions or feedback? Contact <strong>arczeus</strong> on Discord.
            </div>
        </div>
    </div>

    <div class="quick-notes">
        <div class="quick-notes-title">Quick Notes</div>
        <div class="quick-notes-list" id="quickNotesList"></div>
        <div class="add-note-container">
            <input type="text" id="newQuickNote" class="add-note-input" placeholder="Add note...">
            <button class="add-note-btn" onclick="addQuickNote()">+</button>
        </div>
    </div>

    <script>
        let seriesData = {};
        let quickNotes = ['⭐', '✨', '💕', '#fefefe', '#000000'];
        let currentGrouping = 'series';
        let currentSortMethod = 'alpha';
        let isRankingEnabled = true;
        let showDeselected = true;

        function initQuickNotes() {
            displayQuickNotes();
        }

        function setGrouping(method) {
            currentGrouping = method;
            const buttons = document.querySelectorAll('#group-series-btn, #group-note-btn, #group-keys-btn, #group-nogroup-btn, #group-kakera-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`group-${method}-btn`).classList.add('active');

            const kakeraRangeContainer = document.getElementById('kakera-range-container');
            if (method === 'kakera') {
                kakeraRangeContainer.style.display = 'block';
            } else {
                kakeraRangeContainer.style.display = 'none';
            }

            displaySeries();
            // showMessage(`Grouping by ${method}`, 'success');
        }

        function sortGroups(method) {
            if (Object.keys(seriesData).length === 0) {
                //showMessage('No data to sort!', 'error');
                return;
            }
            currentSortMethod = method;

            const buttons = document.querySelectorAll('#sort-alpha-btn, #sort-count-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`sort-${method}-btn`).classList.add('active');

            displaySeries();
            //showMessage(`Sorted by ${method === 'alpha' ? 'A-Z' : 'character count'}`, 'success');
        }
        function toggleRanking(enabled) {
            isRankingEnabled = enabled;
            document.getElementById('ranking-on-btn').classList.toggle('active', enabled);
            document.getElementById('ranking-off-btn').classList.toggle('active', !enabled);

            if (Object.keys(seriesData).length > 0) {
                displaySeries();
            }
            //showMessage(`Ranking is now ${enabled ? 'enabled' : 'disabled'}.`, 'success');
        }
        function changeGridColumns(columns) {
            const grid = document.getElementById('seriesGrid');
            if (grid) {
                grid.style.gridTemplateColumns = `repeat(${columns}, minmax(300px, 1fr))`;
            }

            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`grid-btn-${i}`);
                if (btn) btn.classList.remove('active');
            }
            const activeBtn = document.getElementById(`grid-btn-${columns}`);
            if (activeBtn) activeBtn.classList.add('active');

            localStorage.setItem('mudaeGridColumns', columns);
        }
        function toggleDeselectedVisibility(shouldShow) {
            showDeselected = shouldShow;
            document.getElementById('deselected-show-btn').classList.toggle('active', shouldShow);
            document.getElementById('deselected-hide-btn').classList.toggle('active', !shouldShow);

            if (Object.keys(seriesData).length > 0) {
                displaySeries();
            }

            saveToLocalStorage();
            //showMessage(`Deselected characters are now ${shouldShow ? 'shown' : 'hidden'}.`, 'success');
        }
        function displayQuickNotes() {
            const list = document.getElementById('quickNotesList');
            list.innerHTML = '';

            const isColorCode = /^#([0-9a-fA-F]{3}){1,2}$/;

            quickNotes.forEach(function (note, idx) {
                const noteEl = document.createElement('div');
                noteEl.className = 'quick-note';
                noteEl.onclick = function (e) {
                    if (!e.target.classList.contains('quick-note-remove')) {
                        copyToClipboard(note);
                    }
                };

                const isColor = isColorCode.test(note);

                if (isColor) {
                    const colorIndicator = document.createElement('div');
                    colorIndicator.className = 'color-indicator';
                    colorIndicator.style.cssText = `background-color: ${note}; width: 12px; height: 12px; border: none;`;
                    noteEl.appendChild(colorIndicator);

                    const noteText = document.createTextNode(note);
                    noteEl.appendChild(noteText);
                } else {
                    const noteText = document.createTextNode(note);
                    noteEl.appendChild(noteText);
                }

                const removeSpan = document.createElement('span');
                removeSpan.className = 'quick-note-remove';
                removeSpan.textContent = '×';
                removeSpan.title = 'Remove';
                removeSpan.onclick = function (e) {
                    e.stopPropagation();
                    removeQuickNote(idx);
                };

                noteEl.appendChild(document.createTextNode(' '));
                noteEl.appendChild(removeSpan);
                list.appendChild(noteEl);
            });
        }

        function addQuickNote() {
            const input = document.getElementById('newQuickNote');
            const note = input.value.trim();
            if (note && quickNotes.indexOf(note) === -1) {
                quickNotes.push(note);
                displayQuickNotes();
                input.value = '';
            }
            saveToLocalStorage();
        }

        function removeQuickNote(idx) {
            quickNotes.splice(idx, 1);
            displayQuickNotes();
            saveToLocalStorage();
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(function () {
                // showMessage('Copied: ' + text, 'success');
            });
        }

        window.addEventListener('DOMContentLoaded', function () {
            initQuickNotes();
            loadFromLocalStorage();
        });

        function parseInput() {
            const input = document.getElementById('input').value.trim();
            if (!input) {
                // showMessage('Please paste your $mmasi-[y+][k][n] (brackets are optional) output first!', 'error');
                return;
            }

            seriesData = {};
            const lines = input.split('\n');
            let currentSeries = null;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (!line) continue;

                const seriesMatch = line.match(/^(.+?)\s*-\s*(\d+)\/(\d+)$/);
                if (seriesMatch) {
                    currentSeries = seriesMatch[1].trim();
                    seriesData[currentSeries] = {
                        total: parseInt(seriesMatch[3]),
                        owned: parseInt(seriesMatch[2]),
                        characters: [],
                        note: ''
                    };
                } else if (currentSeries) {
                    // General structure: Name [| note] [· :keytype: (count) (#color)] [kakera ka] - url
                    const charMatch = line.match(/^(.+?)\s+-\s+(https?:\/\/.+)$/);
                    if (charMatch) {
                        let fullInfo = charMatch[1].trim();
                        const imageUrl = charMatch[2].trim();

                        let kakera = '';
                        let keys = '';
                        let color = '';
                        let note = '';
                        let cleanName = fullInfo;
                        let isDisabled = false;

                        // 1. Extract Kakera (always at the end before URL)
                        const kakeraMatch = fullInfo.match(/([\d,]+)\s*ka\s*$/);
                        if (kakeraMatch) {
                            kakera = kakeraMatch[1].replace(/,/g, '');
                            fullInfo = fullInfo.substring(0, kakeraMatch.index).trim();
                        }

                        // 2. Extract Color, Keys, Keytype, Count (part of fullInfo)
                        const colorMatch = fullInfo.match(/\(#([0-9a-fA-F]{6})\)/);
                        if (colorMatch) {
                            color = '#' + colorMatch[1];
                            fullInfo = fullInfo.replace(colorMatch[0], '').trim();
                        }

                        // 3. Extract Key Count (part of fullInfo, usually after color removal if present)
                        const keysMatch = fullInfo.match(/\((\d+)\)/);
                        if (keysMatch) {
                            keys = keysMatch[1];
                            fullInfo = fullInfo.replace(keysMatch[0], '').trim();
                        }

                        // 4. Clean up Key Type and separator
                        fullInfo = fullInfo.replace(/:(?:bronze|silver|gold|chaos)key:/gi, '').trim();

                        fullInfo = fullInfo.replace(/\(\$toggle[a-zA-Z]+\)/g, '').trim();

                        // Check for the disabled symbol 🚫
                        if (fullInfo.includes('🚫')) {
                            isDisabled = true;
                            fullInfo = fullInfo.replace('🚫', '').trim();
                        }

                        fullInfo = fullInfo.replace(/\s*·\s*$/, '').trim();

                        // 5. Extract Name and Note (Name | Note or just Name)
                        const pipeIndex = fullInfo.indexOf('|');
                        if (pipeIndex !== -1) {
                            cleanName = fullInfo.substring(0, pipeIndex).trim();
                            note = fullInfo.substring(pipeIndex + 1).trim();
                        } else {
                            cleanName = fullInfo;
                        }

                        seriesData[currentSeries].characters.push({
                            name: cleanName,
                            displayName: cleanName,
                            image: imageUrl,
                            excluded: false,
                            kakera: kakera,
                            keys: keys,
                            note: note,
                            color: color,
                            isDisabled: isDisabled,
                            rank: 0
                        });
                    }
                }
            }

            if (Object.keys(seriesData).length === 0) {
                //showMessage('No valid data found. Please check your input format.', 'error');
                return;
            }

            displaySeries();
            updateStats();
            //showMessage('Successfully parsed ' + Object.keys(seriesData).length + ' series!', 'success');
            document.getElementById('generateBtn').disabled = false;
            saveToLocalStorage();
        }

        function createCharacterCard(char, groupChars) {
            const charCard = document.createElement('div');
            charCard.dataset.originalSeries = char.originalSeries;
            charCard.dataset.originalIndex = char.originalIndex;

            let classNames = ['character-card'];
            if (char.excluded) classNames.push('excluded');
            if (char.isDisabled) classNames.push('permanently-disabled');
            if (char.excluded && !showDeselected) classNames.push('hidden-char');
            charCard.className = classNames.join(' ');

            const colorCode = char.color || '#670d08';
            charCard.style.borderColor = colorCode;
            charCard.onclick = (event) => toggleCharacter(char.originalSeries, char.originalIndex, event.currentTarget);
            const img = document.createElement('img');
            img.src = char.image;
            img.alt = char.name;
            img.onerror = function () {
                this.style.display = 'none';
                const placeholder = document.createElement('div');
                placeholder.style.cssText = 'width: 135px; height: 210px; background: #2a2a3a; display: flex; align-items: center; justify-content: center; color: #6b7280; font-size: 0.8em; text-align: center; padding: 10px;';
                placeholder.textContent = 'No Image';
                this.parentNode.insertBefore(placeholder, this);
            };

            const infoDiv = document.createElement('div');
            infoDiv.className = 'character-info';

            const nameDiv = document.createElement('div');
            nameDiv.className = 'character-name';
            nameDiv.textContent = char.name;
            nameDiv.title = char.name;

            const noteDiv = document.createElement('div');
            noteDiv.className = 'character-note';
            const hasNote = char.note && char.note.trim() !== '';
            noteDiv.style.cssText = 'background: #13131a; padding: 4px 4px; font-size: 0.7em; color: ' + (hasNote ? '#9ca3af' : '#dc2626; font-weight: bold') + '; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; border-radius: 4px;';
            noteDiv.title = hasNote ? char.note : 'Click to add note';
            noteDiv.textContent = hasNote ? char.note : 'No note!';

            noteDiv.onclick = function (e) {
                e.stopPropagation();
                const originalNoteDiv = this;
                originalNoteDiv.style.display = 'none';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = char.note;
                input.style.cssText = 'width: 100%; box-sizing: border-box; font-size: 0.7em; text-align: center; padding: 3px; border: 1px solid #7c3aed; background: #1a1a24; color: #e5e7eb; border-radius: 4px;';

                originalNoteDiv.parentNode.insertBefore(input, originalNoteDiv);
                input.focus();
                input.select();

                const saveAndClose = () => {
                    const newNote = input.value.trim();
                    seriesData[char.originalSeries].characters[char.originalIndex].note = newNote;
                    saveToLocalStorage();

                    if (currentGrouping === 'note') {
                        displaySeries();
                    } else {
                        const newHasNote = newNote !== '';
                        originalNoteDiv.textContent = newHasNote ? newNote : 'No note!';
                        originalNoteDiv.title = newHasNote ? newNote : 'Click to add note';
                        originalNoteDiv.style.color = newHasNote ? '#9ca3af' : '#dc2626';
                        originalNoteDiv.style.fontWeight = newHasNote ? 'normal' : 'bold';

                        if (input.parentNode) {
                            input.parentNode.removeChild(input);
                        }
                        originalNoteDiv.style.display = '';
                    }
                };

                input.onblur = saveAndClose;
                input.onkeydown = (event) => {
                    if (event.key === 'Enter') saveAndClose();
                    else if (event.key === 'Escape') {
                        if (input.parentNode) input.parentNode.removeChild(input);
                        originalNoteDiv.style.display = '';
                    }
                };
            };

            const statsDiv = document.createElement('div');
            statsDiv.className = 'character-stats';
            const kakeraBadge = document.createElement('div');
            kakeraBadge.className = 'stat-badge';
            kakeraBadge.innerHTML = `<div class="stat-badge-label">Ka</div><div class="stat-badge-value">${char.kakera || '?'}</div>`;
            const keysBadge = document.createElement('div');
            keysBadge.className = 'stat-badge';
            keysBadge.innerHTML = `<div class="stat-badge-label">Keys</div><div class="stat-badge-value">${char.keys || '?'}</div>`;
            statsDiv.appendChild(kakeraBadge);
            statsDiv.appendChild(keysBadge);

            infoDiv.appendChild(nameDiv);
            infoDiv.appendChild(noteDiv);
            infoDiv.appendChild(statsDiv);
            if (isRankingEnabled) {
                const rankBadge = document.createElement('div');
                rankBadge.className = 'character-rank-badge';
                rankBadge.textContent = char.rank > 0 ? char.rank : '#';

                rankBadge.onclick = (e) => {
                    e.stopPropagation();
                    const currentBadge = e.target;
                    const oldRankText = currentBadge.textContent;
                    const oldRank = oldRankText === '#' ? 0 : parseInt(oldRankText);
                    currentBadge.style.display = 'none';

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'rank-input';
                    input.value = oldRank > 0 ? oldRank : '';

                    charCard.prepend(input);
                    input.focus();
                    input.select();

                    const saveRank = () => {
                        let newRank = parseInt(input.value);
                        if (isNaN(newRank) || newRank < 1) newRank = oldRank;

                        groupChars.forEach(otherChar => {
                            const otherCharData = seriesData[otherChar.originalSeries].characters[otherChar.originalIndex];
                            if (otherChar.originalSeries === char.originalSeries && otherChar.originalIndex === char.originalIndex) return;

                            if (newRank < oldRank && otherCharData.rank >= newRank && otherCharData.rank < oldRank) {
                                otherCharData.rank++;
                            } else if (newRank > oldRank && otherCharData.rank <= newRank && otherCharData.rank > oldRank) {
                                otherCharData.rank--;
                            }
                        });

                        seriesData[char.originalSeries].characters[char.originalIndex].rank = newRank;
                        saveToLocalStorage();
                        displaySeries();
                    };

                    input.onblur = saveRank;
                    input.onkeydown = (event) => {
                        if (event.key === 'Enter') saveRank();
                        if (event.key === 'Escape') {
                            if (input.parentNode) input.parentNode.removeChild(input);
                            currentBadge.style.display = 'block';
                        }
                    };
                };
                charCard.appendChild(rankBadge);
            }

            charCard.appendChild(img);
            charCard.appendChild(infoDiv);

            return charCard;
        }

        function updateSelectionView(deselectAll) {
            const allCards = document.querySelectorAll('.character-card');
            allCards.forEach(card => {
                if (deselectAll) {
                    card.classList.add('excluded');
                } else {
                    card.classList.remove('excluded');
                }
            });

            const allToggleBtns = document.querySelectorAll('.series-toggle-btn');
            allToggleBtns.forEach(btn => {
                if (deselectAll) {
                    btn.classList.add('disabled');
                    btn.textContent = 'Enable All';
                } else {
                    btn.classList.remove('disabled');
                    btn.textContent = 'Disable All';
                }
            });

            if (currentGrouping !== 'series') {
                const allGroupCards = document.querySelectorAll('.series-card');
                allGroupCards.forEach(groupCard => {
                    const countEl = groupCard.querySelector('.series-count');
                    const total = groupCard.dataset.totalChars;
                    if (countEl && total) {
                        const newCount = deselectAll ? 0 : total;
                        countEl.textContent = `${newCount}/${total}`;
                    }
                });
            }
        }

        function selectAllCharacters() {
            if (Object.keys(seriesData).length === 0) {
                //showMessage('No characters to select!', 'error');
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    char.excluded = false;
                });
            }

            updateSelectionView(false);
            updateStats();
            saveToLocalStorage();
            //showMessage('All characters selected', 'success');
        }

        function deselectAllCharacters() {
            if (Object.keys(seriesData).length === 0) {
                //showMessage('No characters to deselect!', 'error');
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    char.excluded = true;
                });
            }

            updateSelectionView(true);
            updateStats();
            saveToLocalStorage();
            //showMessage('All characters deselected', 'success');
        }

        function displaySeries() {
            const grid = document.getElementById('seriesGrid');
            grid.innerHTML = '';
            if (Object.keys(seriesData).length === 0) return;

            const groups = {};
            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach((char, idx) => {
                    let groupKey;
                    switch (currentGrouping) {
                        case 'note':
                            groupKey = char.note.trim() || '(No Note)';
                            break;
                        case 'keys':
                            groupKey = char.keys ? `${char.keys} Keys` : '0 Keys';
                            break;
                        case 'nogroup':
                            groupKey = 'All Characters';
                            break;
                        case 'kakera':
                            const rangeSize = parseInt(document.getElementById('kakera-range-input').value) || 1000;
                            const charKakera = parseInt(char.kakera) || 0;
                            const lowerBound = Math.floor(charKakera / rangeSize) * rangeSize;
                            const upperBound = lowerBound + rangeSize - 1;
                            groupKey = `${lowerBound} - ${upperBound} ka`;
                            break;
                        case 'series':
                        default:
                            groupKey = seriesName;
                            break;
                    }
                    if (!groups[groupKey]) {
                        groups[groupKey] = { characters: [] };
                    }
                    groups[groupKey].characters.push({ ...char, originalSeries: seriesName, originalIndex: idx });
                });
            }

            const sortedGroupEntries = Object.entries(groups).sort((a, b) => {
                const [keyA, dataA] = a;
                const [keyB, dataB] = b;
                if (currentSortMethod === 'count') {
                    return dataB.characters.length - dataA.characters.length;
                }
                if (currentGrouping === 'kakera') {
                    const valA = parseInt(keyA.split(' ')[0]);
                    const valB = parseInt(keyB.split(' ')[0]);
                    return valA - valB;
                }
                return keyA.localeCompare(keyB);
            });

            for (const [groupName, data] of sortedGroupEntries) {
                const card = document.createElement('div');
                card.className = 'series-card';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'series-header';
                const titleDiv = document.createElement('div');
                titleDiv.className = 'series-title';
                titleDiv.textContent = groupName;
                titleDiv.title = groupName;

                const countDiv = document.createElement('div');
                countDiv.className = 'series-count';
                const includedCount = data.characters.filter(c => !c.excluded).length;
                countDiv.textContent = `${includedCount}/${data.characters.length}`;
                card.dataset.totalChars = data.characters.length;

                headerDiv.appendChild(titleDiv);
                headerDiv.appendChild(countDiv);
                card.appendChild(headerDiv);

                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'card-controls';

                const topControlsRow = document.createElement('div');
                topControlsRow.className = 'controls-row';

                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'series-toggle-btn';
                const allExcluded = data.characters.every(c => c.excluded);
                toggleBtn.classList.toggle('disabled', allExcluded);
                toggleBtn.textContent = allExcluded ? 'Enable All' : 'Disable All';
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleGroup(data.characters, e);
                };
                topControlsRow.appendChild(toggleBtn);

                const sortButtonsContainer = document.createElement('div');
                sortButtonsContainer.className = 'sort-buttons';
                sortButtonsContainer.innerHTML = `<span style="font-size: 0.8em; color: #9ca3af; margin-right: 5px;">Sort:</span>`;

                const sortOptions = [
                    {
                        label: 'Original', default: true, func: (a, b) => {
                            const seriesCompare = a.originalSeries.localeCompare(b.originalSeries);
                            if (seriesCompare !== 0) return seriesCompare;
                            return a.originalIndex - b.originalIndex;
                        }
                    },
                    { label: 'A-Z', func: (a, b) => a.name.localeCompare(b.name) },
                    { label: 'Kakera', func: (a, b) => parseInt(b.kakera || 0) - parseInt(a.kakera || 0) },
                    { label: 'Keys', func: (a, b) => parseInt(b.keys || 0) - parseInt(a.keys || 0) }
                ];

                sortOptions.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.label;
                    if (option.default) {
                        button.classList.add('active');
                    }
                    button.onclick = (e) => {
                        e.target.parentElement.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        reRankAndRender(option.func);
                    };
                    sortButtonsContainer.appendChild(button);
                });

                topControlsRow.appendChild(sortButtonsContainer);
                controlsDiv.appendChild(topControlsRow);

                const noteInputContainer = document.createElement('div');
                noteInputContainer.className = 'controls-row note-applicator';
                const noteInput = document.createElement('input');
                noteInput.type = 'text';
                noteInput.className = 'note-input';
                noteInput.placeholder = 'Enter group note...';
                noteInput.style.flexGrow = '1';

                const applyButton = document.createElement('button');
                applyButton.className = 'apply-btn';
                applyButton.textContent = 'Apply';
                noteInputContainer.appendChild(noteInput);
                noteInputContainer.appendChild(applyButton);
                controlsDiv.appendChild(noteInputContainer);
                card.appendChild(controlsDiv);

                const charList = document.createElement('div');
                charList.className = 'characters-list';
                card.appendChild(charList);

                let currentlyDisplayedChars = [...data.characters];

                const reRankAndRender = (sortFunction) => {
                    currentlyDisplayedChars.forEach(char => {
                        const freshCharData = seriesData[char.originalSeries].characters[char.originalIndex];
                        char.excluded = freshCharData.excluded;
                    });

                    const sortedChars = [...currentlyDisplayedChars].sort(sortFunction);

                    if (isRankingEnabled) {
                        sortedChars.forEach((char, index) => {
                            seriesData[char.originalSeries].characters[char.originalIndex].rank = index + 1;
                            char.rank = index + 1;
                        });
                        saveToLocalStorage();
                    }

                    currentlyDisplayedChars = sortedChars;

                    charList.innerHTML = '';
                    currentlyDisplayedChars.forEach(char => {
                        charList.appendChild(createCharacterCard(char, currentlyDisplayedChars));
                    });
                };

                applyButton.onclick = () => {
                    const newNote = noteInput.value.trim();

                    data.characters.forEach(char => {
                        seriesData[char.originalSeries].characters[char.originalIndex].note = newNote;
                        char.note = newNote;
                    });

                    saveToLocalStorage();
                    //showMessage(`Applied note to ${data.characters.length} characters.`, 'success');

                    if (currentGrouping === 'note') {
                        displaySeries();
                    } else {
                        // Just update the DOM, don't re-render the whole group
                        charList.querySelectorAll('.character-card').forEach(cardElement => {
                            const noteDiv = cardElement.querySelector('.character-note');
                            if (noteDiv) {
                                const hasNote = newNote !== '';
                                noteDiv.textContent = hasNote ? newNote : 'No note!';
                                noteDiv.title = hasNote ? newNote : 'Click to add note';
                                noteDiv.style.color = hasNote ? '#9ca3af' : '#dc2626';
                                noteDiv.style.fontWeight = hasNote ? 'normal' : 'bold';
                            }
                        });
                    }
                };

                const initialRender = () => {
                    if (isRankingEnabled) {
                        if (currentlyDisplayedChars.every(c => c.rank === 0)) {
                            currentlyDisplayedChars.forEach((char, index) => {
                                char.rank = index + 1;
                                seriesData[char.originalSeries].characters[char.originalIndex].rank = index + 1;
                            });
                        }
                        currentlyDisplayedChars.sort((a, b) => a.rank - b.rank);
                    }

                    charList.innerHTML = '';
                    currentlyDisplayedChars.forEach(char => {
                        charList.appendChild(createCharacterCard(char, currentlyDisplayedChars));
                    });
                };

                initialRender();

                const hasVisibleChars = charList.querySelector('.character-card:not(.hidden-char)');
                if (showDeselected || hasVisibleChars) {
                    grid.appendChild(card);
                }
            }
        }

        function toggleCharacter(seriesName, charIdx, cardElement) {
            if (!seriesData[seriesName] || !seriesData[seriesName].characters[charIdx]) return;

            const char = seriesData[seriesName].characters[charIdx];
            char.excluded = !char.excluded;

            cardElement.classList.toggle('excluded', char.excluded);

            const groupCard = cardElement.closest('.series-card');
            if (groupCard) {
                if (currentGrouping !== 'series') {
                    const countEl = groupCard.querySelector('.series-count');
                    if (countEl) {
                        const parts = countEl.textContent.split('/');
                        let includedCount = parseInt(parts[0], 10);
                        includedCount += char.excluded ? -1 : 1;
                        countEl.textContent = `${includedCount}/${parts[1]}`;
                    }
                }

                const allExcludedInGroup = !groupCard.querySelector('.character-card:not(.excluded)');

                const toggleBtn = groupCard.querySelector('.series-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.classList.toggle('disabled', allExcludedInGroup);
                    toggleBtn.textContent = allExcludedInGroup ? 'Enable All' : 'Disable All';
                }
            }

            updateStats();
            saveToLocalStorage();
        }

        function toggleGroup(charactersInGroup, event) {
            if (!charactersInGroup || charactersInGroup.length === 0) return;

            const allExcluded = charactersInGroup.every(c => seriesData[c.originalSeries].characters[c.originalIndex].excluded);
            const shouldExclude = !allExcluded;

            charactersInGroup.forEach(char => {
                seriesData[char.originalSeries].characters[char.originalIndex].excluded = shouldExclude;
            });

            const button = event.currentTarget;
            const groupCard = button.closest('.series-card');

            if (groupCard) {
                button.classList.toggle('disabled', shouldExclude);
                button.textContent = shouldExclude ? 'Enable All' : 'Disable All';

                const charCardsInGroup = groupCard.querySelectorAll('.character-card');
                charCardsInGroup.forEach(card => {
                    card.classList.toggle('excluded', shouldExclude);
                });

                const countEl = groupCard.querySelector('.series-count');
                const total = groupCard.dataset.totalChars;
                if (countEl && total) {
                    const newCount = shouldExclude ? 0 : total;
                    countEl.textContent = `${newCount}/${total}`;
                }
            }

            updateStats();
            saveToLocalStorage();
        }

        function updateStats() {
            const totalSeries = Object.keys(seriesData).length;
            let totalChars = 0;
            let includedChars = 0;

            for (let key in seriesData) {
                const data = seriesData[key];
                totalChars += data.characters.length;
                includedChars += data.characters.filter(function (c) { return !c.excluded; }).length;
            }

            const stats = document.getElementById('stats');
            stats.innerHTML = '<div class="stats">' +
                '<div class="stat-item">' +
                '<div class="stat-label">Total Series</div>' +
                '<div class="stat-value">' + totalSeries + '</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="stat-label">Total Characters</div>' +
                '<div class="stat-value">' + totalChars + '</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="stat-label">Included Characters</div>' +
                '<div class="stat-value">' + includedChars + '</div>' +
                '</div>' +
                '</div>';
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function generateCommands() {
            const commandsDiv = document.getElementById('commands');
            commandsDiv.innerHTML = `
    <div class="commands-section">
        <h2 style="display: flex; justify-content: space-between; align-items: center;">
            Generated Commands
            <button onclick="scrollToTop()" style="font-size: 0.7em; padding: 6px 12px;">Go to Top ↑</button>
        </h2>
    </div>`;
            const container = commandsDiv.querySelector('.commands-section');

            const commandsByNote = {};
            let totalSelectedCharacters = 0;

            const allSelectedCards = document.querySelectorAll('#seriesGrid .character-card:not(.excluded)');

            const orderedSelectedChars = Array.from(allSelectedCards).map(card => {
                const seriesName = card.dataset.originalSeries;
                const charIndex = parseInt(card.dataset.originalIndex, 10);
                return seriesData[seriesName].characters[charIndex];
            });

            for (const char of orderedSelectedChars) {
                if (!char.excluded) {
                    totalSelectedCharacters++;
                    const note = char.note ? char.note.trim() : '';
                    if (!commandsByNote[note]) {
                        commandsByNote[note] = [];
                    }
                    commandsByNote[note].push(char);
                }
            }

            const sortedNotes = Object.keys(commandsByNote).sort((a, b) => a.localeCompare(b));

            for (const note of sortedNotes) {
                const charsWithThisNote = commandsByNote[note];
                const allCharsNames = charsWithThisNote.map(c => c.name);

                let commandParts = [];
                const commandPrefix = '$n ';
                const commandSuffix = note ? ` $ ${note}` : '';
                let currentCharacterString = '';

                for (const charName of allCharsNames) {
                    const separator = currentCharacterString ? '$' : '';
                    const potentialNextString = currentCharacterString + separator + charName;

                    if ((commandPrefix.length + potentialNextString.length + commandSuffix.length) > 1990) {
                        const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                        commandParts.push(finalCommand);
                        currentCharacterString = charName;
                    } else {
                        currentCharacterString = potentialNextString;
                    }
                }

                if (currentCharacterString) {
                    const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                    commandParts.push(finalCommand);
                }

                commandParts.forEach((command, idx) => {
                    const commandItem = document.createElement('div');
                    commandItem.className = 'command-item';

                    let headerText = `Note: ${note || 'None'}`;
                    headerText += ` - ${allCharsNames.length} character${allCharsNames.length > 1 ? 's' : ''}`;
                    if (commandParts.length > 1) {
                        headerText += ` (Part ${idx + 1}/${commandParts.length})`;
                    }

                    commandItem.innerHTML = `
                        <div class="command-header">
                            <div class="command-series">${headerText}</div>
                        </div>
                        <div class="command-text">${command}</div>
                        <button class="copy-btn" onclick="copyCommand(this, \`${command.replace(/`/g, '\\`')}\`)">Copy Command</button>
                    `;
                    container.appendChild(commandItem);
                });
            }

            if (totalSelectedCharacters === 0) {
                const p = document.createElement('p');
                p.style.color = '#6b7280';
                p.style.padding = '20px';
                p.textContent = 'No commands to generate. Please select at least one character.';
                container.appendChild(p);
            }

            const commandsContainer = document.getElementById('commands').querySelector('.command-item');
            if (commandsContainer) {
                document.getElementById('goToCommandsBtn').style.display = 'inline-block';
            } else {
                document.getElementById('goToCommandsBtn').style.display = 'none';
            }
        }

        function scrollToCommands() {
            const commandsSection = document.getElementById('commands');
            if (commandsSection) {
                commandsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function copyCommand(btn, command) {
            navigator.clipboard.writeText(command).then(function () {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#28a745';
                setTimeout(function () {
                    btn.textContent = originalText;
                    btn.style.background = '#7c3aed';
                }, 2000);
            });
        }

        function clearAll() {
            if (Object.keys(seriesData).length > 0) {
                if (!confirm('Are you sure you want to clear all data?')) return;
            }

            seriesData = {};
            currentGrouping = 'series';
            currentSortMethod = 'alpha';

            document.getElementById('input').value = '';
            document.getElementById('seriesGrid').innerHTML = '';
            document.getElementById('commands').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
            document.getElementById('message').innerHTML = '';
            document.getElementById('message').className = 'empty';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('goToCommandsBtn').style.display = 'none';
            localStorage.removeItem('mudaeSeriesData');
            localStorage.removeItem('mudaeQuickNotes');
        }
        function applyFilter() {
            if (Object.keys(seriesData).length === 0) {
                //showMessage('No data to filter!', 'error');
                return;
            }

            const minKakera = parseInt(document.getElementById('min-kakera').value) || 0;
            const maxKakera = parseInt(document.getElementById('max-kakera').value) || Infinity;
            const minKeys = parseInt(document.getElementById('min-keys').value) || 0;
            const maxKeys = parseInt(document.getElementById('max-keys').value) || Infinity;

            let deselectedCount = 0;

            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(char => {
                    const charKakera = parseInt(char.kakera) || 0;
                    const charKeys = parseInt(char.keys) || 0;

                    const shouldDeselect =
                        charKakera < minKakera ||
                        charKakera > maxKakera ||
                        charKeys < minKeys ||
                        charKeys > maxKeys;

                    if (shouldDeselect) {
                        if (!char.excluded) {
                            deselectedCount++;
                        }
                        char.excluded = true;
                    }
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
            //showMessage(`Deselected ${deselectedCount} characters based on the filter.`, 'success');
        }
        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = text;
            setTimeout(function () {
                messageDiv.innerHTML = '';
                messageDiv.className = 'empty-message'
            }, 5000);
        }

        function saveToLocalStorage() {
            try {
                localStorage.setItem('mudaeSeriesData', JSON.stringify(seriesData));
                localStorage.setItem('mudaeQuickNotes', JSON.stringify(quickNotes));
                localStorage.setItem('mudaeRankingEnabled', JSON.stringify(isRankingEnabled));
                localStorage.setItem('mudaeShowDeselected', JSON.stringify(showDeselected));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedSeries = localStorage.getItem('mudaeSeriesData');
                const savedNotes = localStorage.getItem('mudaeQuickNotes');

                if (savedSeries) {
                    seriesData = JSON.parse(savedSeries);
                    displaySeries();
                    updateStats();
                    document.getElementById('generateBtn').disabled = Object.keys(seriesData).length === 0;
                }

                if (savedNotes) {
                    quickNotes = JSON.parse(savedNotes);
                    displayQuickNotes();
                }

                const savedColumns = localStorage.getItem('mudaeGridColumns');
                if (savedColumns) {
                    changeGridColumns(parseInt(savedColumns, 10));
                } else {
                    changeGridColumns(3);
                }

                const savedRankingState = localStorage.getItem('mudaeRankingEnabled');
                if (savedRankingState !== null) {
                    toggleRanking(JSON.parse(savedRankingState));
                }

                const savedShowDeselected = localStorage.getItem('mudaeShowDeselected');
                if (savedShowDeselected !== null) {
                    toggleDeselectedVisibility(JSON.parse(savedShowDeselected));
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
        }
    </script>
</body>

</html>