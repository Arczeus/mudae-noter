<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>Mudae Noter</title>
    <link rel="icon" type="image/png" href="https://cdn.imgchest.com/files/59a3ca5bc2d6.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .container {
            max-width: 1610px;
            background: #13131a;
            border-radius: 15px;
            padding: 30px;
            border: 1px solid #1f1f2e;
            display: flex;
            flex-direction: column;
        }

        .header-row {
            margin-bottom: 25px;
        }

        h1 {
            color: #a78bfa;
            margin-bottom: 10px;
            font-size: 2em;
        }

        h2 {
            color: #a78bfa;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #9ca3af;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .instructions-list {
            list-style: none;
            padding-left: 0;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px 20px;
            color: #d1d5db;
        }

        .instruction-item {
            font-size: 0.9em;
            line-height: 1.4;
            display: flex;
            align-items: baseline;
        }

        .instruction-item b {
            margin-left: 2px;
            margin-right: 2px;
            flex-shrink: 0;
        }

        .instruction-item strong {
            color: #a78bfa;
            margin-right: 5px;
            flex-shrink: 0;
        }

        .instruction-item code {
            background: #2a2a3a;
            padding: 2px 4px;
            border-radius: 4px;
            margin-right: 5px;
            margin-left: 5px;
            font-size: 0.9em;
            color: #4ade80;
        }

        .instruction-badge {
            background: #a78bfa;
            color: #0a0a0f;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 0.85em;
            margin: 0 5px;
        }

        .dimmed {
            opacity: 0.6;
            font-style: italic;
            color: #9ca3af;
            margin-left: 2px;
            margin-right: 2px;
        }

        .quick-notes {
            background: #13131a;
            border-radius: 15px;
            padding: 20px;
            width: 280px;
            border: 1px solid #1f1f2e;
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 40px);
        }

        .quick-notes-title {
            font-size: 1.1em;
            font-weight: 700;
            color: #a78bfa;
            margin-bottom: 15px;
        }

        .quick-notes-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
            overflow-y: auto;
            scrollbar-gutter: stable;
            padding-right: 5px;
        }

        .quick-note {
            background: #1a1a24;
            border: 2px solid #7c3aed;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 5px;
            color: #e5e7eb;
        }

        .quick-note:hover {
            background: #7c3aed;
            color: white;
        }

        .quick-note.copied {
            background: #059669 !important;
            border-color: #059669 !important;
            color: white !important;
            transform: scale(0.95);
        }

        .quick-note.copied::after {
            font-weight: bold;
        }

        .quick-note-remove {
            font-size: 1.4em;
            margin-left: auto;
            opacity: 0.6;
            padding: 0 8px;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quick-note-remove:hover {
            opacity: 1;
            background-color: #b91c1c;
            color: white;
        }

        .add-note-container {
            display: flex;
            gap: 8px;
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid #2a2a3a;
            min-width: 0;
        }

        .add-note-input {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #2a2a3a;
            border-radius: 5px;
            font-size: 0.9em;
            background: #0a0a0f;
            color: #e5e7eb;
            min-width: 0;
        }

        .add-note-input:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .hidden-char {
            display: none !important;
        }

        .add-note-btn {
            padding: 6px 15px;
            font-size: 0.9em;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-note-btn:hover {
            background-color: #6d28d9;
        }

        label {
            display: block;
            font-weight: 600;
            color: #e5e7eb;
            margin-bottom: 8px;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 2px solid #2a2a3a;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            background: #0a0a0f;
            color: #e5e7eb;
        }

        textarea:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .controls-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 30px;
            align-items: stretch;
        }

        .actions-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input-areas-container {
            display: flex;
            gap: 20px;
            flex-grow: 1;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .input-group textarea {
            flex-grow: 1;
            min-height: 200px;
            resize: vertical;
        }

        .actions-panel,
        .options-panel {
            background: #1a1a24;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #2a2a3a;
        }

        .options-panel {
            grid-column: 2;
            grid-row: 1;
        }

        .options-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 1px solid #2a2a3a;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #e5e7eb;
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            justify-content: flex-start;
        }

        .button-group label {
            margin-bottom: 0;
            font-size: 0.9em;
            color: #9ca3af;
            margin-right: 5px;
        }

        .main-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        #filter-section {
            margin-top: 0;
            padding: 0;
            background: transparent;
            border: none;
        }

        .stats-panel {
            background: transparent;
            border: none;
            padding: 0;
            margin-top: auto;
        }

        .stats {
            display: flex;
            gap: 20px;
            padding-top: 15px;
        }

        .series-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .series-card {
            background: #1a1a24;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2a2a3a;
        }

        .series-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .series-title {
            font-weight: 600;
            color: #e5e7eb;
            font-size: 0.95em;
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .series-count {
            color: #9ca3af;
            font-size: 0.85em;
        }

        .note-input {
            width: 100%;
            padding: 8px;
            border: 2px solid #2a2a3a;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.9em;
            background: #0a0a0f;
            color: #e5e7eb;
        }

        .note-input:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .characters-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .character-card {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 5px solid var(--card-color, transparent);
            border-radius: 8px;
            overflow: hidden;
            width: 135px;
        }

        .character-card img {
            width: 135px;
            height: 210px;
            object-fit: cover;
            display: block;
        }

        .character-card:hover {
            transform: scale(1.05);
            border-color: #a78bfa !important;
        }

        .character-card.excluded {
            filter: opacity(0.5);
        }

        .character-card.excluded img {
            filter: grayscale(100%);
        }

        .container:not(.hide-disabled-emoji) .character-card.permanently-disabled::after {
            content: 'ðŸš«';
            position: absolute;
            top: 105px;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7em;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 10px black;
            pointer-events: none;
        }

        .character-info {
            background: #0a0a0f;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .character-name {
            color: #e5e7eb;
            font-size: 0.7em;
            text-align: center;
            word-break: break-word;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .character-stats {
            display: flex;
            justify-content: space-around;
            gap: 8px;
            font-size: 0.65em;
        }

        .character-owner-badge {
            background-color: rgba(10, 10, 15, 0.8);
            color: #4ade80;
            font-weight: 700;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: default;
            border: 1px solid #4ade80;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }

        .stat-badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .stat-badge-label {
            color: #9ca3af;
            font-size: 0.9em;
        }

        .stat-badge-value {
            color: #a78bfa;
            font-weight: 700;
        }

        .character-rank-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(10, 10, 15, 0.8);
            color: #a78bfa;
            font-weight: 700;
            font-size: 0.9em;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 10;
            cursor: pointer;
            border: 1px solid #a78bfa;
        }

        .rank-input {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 40px;
            z-index: 10;
            text-align: center;
            border: 1px solid #7c3aed;
            background: #1a1a24;
            color: #e5e7eb;
            border-radius: 4px;
        }

        .commands-section {
            margin-top: 30px;
            padding: 20px;
            background: #1a1a24;
            border-radius: 10px;
            border: 1px solid #2a2a3a;
        }

        .command-item {
            background: #13131a;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #7c3aed;
        }

        .command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .command-series {
            font-weight: 600;
            color: #e5e7eb;
        }

        .command-text {
            background: #0a0a0f;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            margin-bottom: 10px;
            color: #d1d5db;
            border: 1px solid #2a2a3a;
        }

        .copy-btn {
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .stat-item {
            flex: 1;
        }

        .stat-label {
            font-size: 0.85em;
            color: #9ca3af;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            color: #a78bfa;
        }

        .error-message {
            background: #7f1d1d;
            color: #fecaca;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #dc2626;
            margin-top: 15px;
        }

        .success-message {
            background: #064e3b;
            color: #6ee7b7;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #10b981;
            margin-top: 15px;
        }

        .empty-message {
            display: none;
        }

        .card-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #13131a;
            border-radius: 8px;
            border: 1px solid #2a2a3a;
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        .controls-row.main-actions {
            justify-content: space-between;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a2a3a;
            margin-bottom: 5px;
        }

        .sort-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .sort-label {
            font-size: 0.85em;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 4px;
        }

        .bulk-apply-group {
            display: flex;
            flex-grow: 1;
            gap: 0;
            background-color: #0a0a0f;
            border-radius: 6px;
            border: 1px solid #2a2a3a;
            align-items: stretch;
            overflow: hidden;
        }

        .bulk-apply-group .note-input {
            flex-grow: 1;
            margin-bottom: 0;
            border: none;
            background: transparent;
            border-radius: 0;
            padding: 8px 12px;
        }

        .bulk-apply-group .note-input:focus {
            box-shadow: inset 0 0 0 1px #7c3aed;
        }

        .apply-btn-group {
            display: flex;
            border-left: 1px solid #2a2a3a;
        }

        .apply-btn-group .btn {
            border-radius: 0;
            margin: 0;
            border: none;
            border-left: 1px solid #2a2a3a;
            font-size: 0.8em;
            padding: 0 15px;
            background: #1f1f2e;
            color: #9ca3af;
        }

        .apply-btn-group .btn:hover {
            background: #7c3aed;
            color: white;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            line-height: 1.2;
            color: #9ca3af;
            background: #2a2a3a;
        }

        .btn:hover {
            color: #e5e7eb;
            background-color: #3f3f50;
        }

        .btn:disabled {
            background: #1f1f2e;
            color: #4b5563;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border-color: transparent;
        }

        .btn-primary {
            background: #7c3aed;
            color: white;
        }

        .btn-primary:hover {
            background: #6d28d9;
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
        }

        .btn-secondary {
            background: #4b5563;
            color: white;
        }

        .btn-secondary:hover {
            background: #374151;
        }

        .btn-danger {
            background: #dc2626;
            color: white;
        }

        .btn-danger:hover {
            background: #b91c1c;
            box-shadow: 0 5px 15px rgba(220, 38, 38, 0.4);
        }

        .btn.active {
            background: #7c3aed;
            color: white;
            box-shadow: 0 4px 10px rgba(124, 58, 237, 0.3);
            border-color: #7c3aed;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.85em;
            border-radius: 6px;
        }

        .apply-btn-group .btn {
            border-radius: 0;
            padding: 8px 12px;
            background: #4b5563;
            color: white;
        }

        .apply-btn-group .btn:hover {
            background: #6d28d9;
        }

        .apply-btn-group .btn:first-child {
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }

        .apply-btn-group .btn:last-child {
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }

        .footer {
            text-align: center;
            padding: 40px 0 0;
            color: #6b7280;
            font-size: 0.85em;
            margin-top: auto;
            position: relative;
        }

        .footer::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #2a2a3a;
        }

        .footer-contact {
            margin-top: 10px;
            font-size: 0.9em;
        }

        .footer-contact strong {
            color: #a78bfa;
        }

        .filter-controls-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            align-items: end;
        }

        .filter-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-control label {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
            font-weight: 700;
            margin-bottom: 0;
        }

        .filter-control input,
        .filter-control select {
            width: 100%;
            background: #0a0a0f;
            border: 1px solid #2a2a3a;
            color: #e5e7eb;
            padding: 8px 12px;
            border-radius: 6px;
            height: 38px;
            font-size: 0.9em;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .filter-control input:focus,
        .filter-control select:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
        }

        .filter-actions {
            grid-column: 1 / -1;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
            padding-top: 15px;
            border-top: 1px solid #2a2a3a;
        }

        .filter-actions button {
            margin-right: 0;
        }

        .stats-compass-container {
            background: #1a1a24;
            border-radius: 15px;
            padding: 40px;
            margin: 30px 0;
            border: 1px solid #2a2a3a;
        }

        .stats-compass-title {
            color: #a78bfa;
            font-size: 2em;
            text-align: center;
            margin-bottom: 30px;
        }

        .compass-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin: 0 auto;
            max-width: 600px;
        }

        .compass-svg {
            width: 100%;
            height: auto;
        }

        .player-legend {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            padding: 20px;
            background: #13131a;
            border-radius: 10px;
            overflow-x: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .legend-name {
            color: #e5e7eb;
            font-weight: 600;
        }

        .legend-stats {
            color: #9ca3af;
            font-size: 0.9em;
        }

        .back-button {
            display: block;
            margin: 20px auto 0;
            padding: 12px 30px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header-row">
            <h1>Mudae Note Manager</h1>
            <div class="instructions-list">
                <p class="instruction-item">
                    <strong>Get Started:</strong> Paste <code>$mmasi-</code> output in the box and&nbsp;<b>Parse
                        Input</b>.
                </p>
                <p class="instruction-item">
                    <strong>More Info:</strong> Use <code>$mmsaty+ri-c+x+ko</code> for extra character data.
                </p>
                <p class="instruction-item">
                    <strong>Multiple Users:</strong> Parse multiple users together in one box or use both boxes.
                </p>
                <p class="instruction-item">
                    <strong>Selection:</strong> Cards can be clicked to toggle selection (<span class="dimmed">gray =
                        deselected</span>).
                </p>
                <p class="instruction-item">
                    <strong>Notes:</strong> Add notes individually or apply in bulk using the group inputs.
                </p>
                <p class="instruction-item">
                    <strong>Sorting:</strong> Groups can be sorted by various stats. Re-clicking a sort will re-rank.
                </p>
                <p class="instruction-item">
                    <strong>Ranking:</strong> Custom order is set by clicking the <span
                        class="instruction-badge">#</span> badge. (Enabled in settings)
                </p>
                <p class="instruction-item">
                    <strong>Generate:</strong> Commands (<code>$n</code>, <code>$ec</code>) are created from selected
                    characters.
                </p>
                <p class="instruction-item">
                    <strong>Quick Notes:</strong> The sidebar holds notes, emojis, or colors for quick copy-paste.
                </p>
                <p class="instruction-item">
                    <strong>Demo:</strong> <button onclick="loadDemoData()" class="btn btn-sm"
                        style="margin: 0 6px;">Load Demo</button>
                    and&nbsp;<b>Parse Input</b>.
                </p>
            </div>
        </div>

        <div class="input-section">
            <div class="controls-container">
                <div class="actions-panel">
                    <div class="input-areas-container">
                        <div class="input-group">
                            <label for="input">Input:</label>
                            <textarea id="input"
                                placeholder="Paste multiple users outputs here (One after another)&#10;=========================================&#10;&#10;Dungeon Meshi - 36/40&#10;#819 - Marcille Donato  ðŸ’ž => arczeus | âœ¨ Â· ($wa) Â· :chaoskey:â€¯â€¯(10) (#EAC57C) 1,304 ka - https://mudae.net/uploads/5107688/ASRKnT0~S2nXASL.gif&#10;#1,683 - Izutsumi  ðŸ’ž => notarczeus | KIBBTTYYYYYYY!!! Â· ($wa) Â· :chaoskey:â€¯â€¯(15) (#000000) 1,171 ka - https://mudae.net/uploads/3371494/ZiG_9A_~g4z9cdzar27.gif&#10;&#10;Monogatari - 35/35&#10;#2,826 - Koyomi Araragi  ðŸ’ž => arczeus | Ararara Â· ($ha) Â· :bronzekey:â€¯â€¯(1) (#4B3E3B) 454 ka - https://mudae.net/uploads/5127825/niqiskC~HDpXTrY.gif&#10;&#10;One Piece - 302/524&#10;#27 - Monkey D. Luffy  ðŸ’ž => arczeus | One Peak Â· ($ha) Â· :silverkey:â€¯â€¯(5) (#000000) 5,138 ka - https://mudae.net/uploads/7762218/dJ4pNeG~yrgcnx9km94.gif&#10;#39 - Roronoa Zoro  ðŸ’ž => arczeus | One Peak Â· ($ha) Â· :silverkey:â€¯â€¯(3) (#9DD65A) 3,986 ka - https://mudae.net/uploads/3151276/N53Uy4-~8975e940ae3f.png&#10;&#10;VOCALOID - 1/86&#10;#2 - Hatsune Miku  ðŸ’ž => arczeus | ðŸ©µ | â­ Â· ($wa, $wg) Â· :chaoskey:â€¯â€¯(999) (#86cecb) 121,272 ka - https://mudae.net/uploads/6428828/OfZtuxp~7pjcqnb6kb7.gif"></textarea>
                        </div>
                    </div>
                    <div class="main-buttons">
                        <button onclick="parseInput()" class="btn btn-primary">Parse Input</button>
                        <button onclick="clearAll()" class="btn btn-primary">Clear All</button>

                        <button onclick="generateNoteCommands()" id="generateBtn" class="btn btn-primary" disabled>
                            Generate Notes
                        </button>

                        <button onclick="generateColorCommands()" id="generateColorBtn" class="btn btn-primary"
                            disabled>
                            Generate Colors
                        </button>

                        <button onclick="showPlayerStats()" id="playerStatsBtn" class="btn btn-primary" disabled>
                            Player Stats
                        </button>


                    </div>
                    <button onclick="scrollToCommands()" id="goToCommandsBtn" class="btn btn-primary"
                        style="display: none;">
                        Go to Commandsâ†“
                    </button>
                    <div id="stats" class="stats-panel"></div>

                </div>

                <div class="options-panel">
                    <h2>Options</h2>

                    <div class="control-group">
                        <h3>Grouping</h3>
                        <div class="button-group" style="gap: 6px;">
                            <button onclick="setGrouping('nogroup')" id="group-nogroup-btn"
                                class="btn btn-sm">None</button>
                            <button onclick="setGrouping('series')" id="group-series-btn"
                                class="btn btn-sm active">Series</button>
                            <button onclick="setGrouping('note')" id="group-note-btn" class="btn btn-sm">Note</button>
                            <button onclick="setGrouping('color')" id="group-color-btn"
                                class="btn btn-sm">Color</button>
                            <button onclick="setGrouping('keys')" id="group-keys-btn" class="btn btn-sm">Keys</button>
                            <button onclick="setGrouping('kakera')" id="group-kakera-btn"
                                class="btn btn-sm">Kakera</button>
                            <button onclick="setGrouping('gender')" id="group-gender-btn"
                                class="btn btn-sm">Gender</button>
                            <button onclick="setGrouping('roulette')" id="group-roulette-btn"
                                class="btn btn-sm">Roulette</button>
                            <button onclick="setGrouping('owner')" id="group-owner-btn"
                                class="btn btn-sm">Owner</button>
                        </div>
                        <div id="kakera-range-container"
                            style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
                            <label for="kakera-range-input" style="margin-bottom: 0;">Range Size:</label>
                            <input type="number" id="kakera-range-input" value="1000" min="1" class="add-note-input"
                                style="width: 120px; flex: none;">
                            <button onclick="displaySeries()" class="btn btn-sm">Apply</button>
                        </div>
                        <div id="keys-range-container"
                            style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
                            <label for="keys-range-input" style="margin-bottom: 0;">Range Size:</label>
                            <input type="number" id="keys-range-input" value="1" min="1" class="add-note-input"
                                style="width: 120px; flex: none;">
                            <button onclick="displaySeries()" class="btn btn-sm">Apply</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Sorting & Display</h3>
                        <div class="button-group">
                            <label>Sort Groups:</label>
                            <button onclick="sortGroups('alpha')" id="sort-alpha-btn" class="btn btn-sm">A-Z</button>
                            <button onclick="sortGroups('count')" id="sort-count-btn"
                                class="btn btn-sm active">Count</button>
                        </div>
                        <div class="button-group">
                            <label>Ranking:</label>
                            <button onclick="toggleRanking(true)" id="ranking-on-btn"
                                class="btn btn-sm active">On</button>
                            <button onclick="toggleRanking(false)" id="ranking-off-btn" class="btn btn-sm">Off</button>
                        </div>
                        <div class="button-group">
                            <label>Deselected:</label>
                            <button onclick="toggleDeselectedVisibility(true)" id="deselected-show-btn"
                                class="btn btn-sm" class="active">Show</button>
                            <button onclick="toggleDeselectedVisibility(false)" id="deselected-hide-btn"
                                class="btn btn-sm">Hide</button>
                        </div>
                        <div class="button-group">
                            <label>Disabled Icon:</label>
                            <button onclick="toggleDisabledIconVisibility(true)" id="disabled-icon-show-btn"
                                class="btn btn-sm" class="active">Show</button>
                            <button onclick="toggleDisabledIconVisibility(false)" class="btn btn-sm"
                                id="disabled-icon-hide-btn">Hide</button>
                        </div>
                        <div class="button-group">
                            <label>Columns:</label>
                            <button onclick="changeGridColumns(1)" id="grid-btn-1" class="btn btn-sm">1</button>
                            <button onclick="changeGridColumns(2)" id="grid-btn-2" class="btn btn-sm">2</button>
                            <button onclick="changeGridColumns(3)" id="grid-btn-3" class="btn btn-sm active">3</button>
                            <button onclick="changeGridColumns(4)" id="grid-btn-4" class="btn btn-sm">4</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Bulk Actions</h3>
                        <div class="button-group">
                            <button onclick="selectAllCharacters()" class="btn btn-sm">Select All</button>
                            <button onclick="deselectAllCharacters()" class="btn btn-sm">Deselect All</button>
                            <button onclick="selectDisabledCharacters()" class="btn btn-sm">Select Disabled</button>
                            <button onclick="deselectDisabledCharacters()" class="btn btn-sm">Deselect Disabled</button>
                        </div>
                    </div>

                    <div class="control-group" id="filter-section">
                        <h3>Filter Characters</h3>
                        <div class="filter-controls-container">
                            <div class="filter-control">
                                <label for="min-kakera">Min Ka</label>
                                <input type="number" id="min-kakera" placeholder="0">
                            </div>
                            <div class="filter-control">
                                <label for="max-kakera">Max Ka</label>
                                <input type="number" id="max-kakera" placeholder="any">
                            </div>
                            <div class="filter-control">
                                <label for="min-keys">Min Keys</label>
                                <input type="number" id="min-keys" placeholder="0">
                            </div>
                            <div class="filter-control">
                                <label for="max-keys">Max Keys</label>
                                <input type="number" id="max-keys" placeholder="any">
                            </div>
                            <div class="filter-control">
                                <label for="filter-owner">Owner</label>
                                <select id="filter-owner">
                                    <option value="any">Any</option>
                                </select>
                            </div>
                            <div class="filter-control">
                                <label for="filter-gender">Gender</label>
                                <select id="filter-gender">
                                    <option value="any">Any</option>
                                    <option value="has_waifu">Has Waifu</option>
                                    <option value="has_husbando">Has Husbando</option>
                                    <option value="only_waifu">Only Waifu</option>
                                    <option value="only_husbando">Only Husbando</option>
                                    <option value="genderless">Genderless / Other</option>
                                </select>
                            </div>
                            <div class="filter-control">
                                <label for="filter-roulette">Roulette</label>
                                <select id="filter-roulette">
                                    <option value="any">Any</option>
                                    <option value="has_animanga">Has Animanga</option>
                                    <option value="has_game">Has Game</option>
                                    <option value="only_animanga">Only Animanga</option>
                                    <option value="only_game">Only Game</option>
                                    <option value="both">Both</option>
                                </select>
                            </div>

                            <div class="filter-actions">
                                <button onclick="applyFilter()" class="btn btn-sm btn-primary">Apply Filter</button>
                                <button onclick="clearFilter()" class="btn btn-sm btn-secondary">Revert</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="message"></div>
        <div id="playerStatsSection" style="display: none;"></div>
        <div id="seriesGrid" class="series-grid"></div>
        <div id="commands"></div>
        <div class="footer">
            <div class="footer-contact">
                Questions, feedback or bugs? Contact <strong>arczeus</strong> on Discord.
            </div>

            <div style="margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 15px;">
                <a href="https://github.com/Arczeus/mudae-noter" target="_blank"
                    style="color: #a78bfa; text-decoration: none; transition: color 0.2s;"
                    onmouseover="this.style.color='#e5e7eb'" onmouseout="this.style.color='#6b7280'">
                    GitHub
                </a>

                <span style="color: #2a2a3a;">|</span>

                <a href="https://buymeacoffee.com/arczeus" target="_blank"
                    style="color: #a78bfa; text-decoration: none; display: inline-flex; align-items: center; gap: 5px; transition: color 0.2s;">
                    Buy Me a Coffee
                </a>
            </div>
        </div>
    </div>

    <div class="quick-notes">
        <div class="quick-notes-title">Quick Notes</div>
        <div class="quick-notes-list" id="quickNotesList"></div>
        <div class="add-note-container">
            <input type="text" id="newQuickNote" class="add-note-input" placeholder="Add note...">
            <button class="add-note-btn" onclick="addQuickNote()">+</button>
        </div>
    </div>

    <script>
        let seriesData = {};
        let quickNotes = ['â­', 'âœ¨', 'ðŸ’•', 'uft', '#fefefe', '#000000'];
        let currentGrouping = 'series';
        let currentSortMethod = 'count';
        let isRankingEnabled = true;
        let showDeselected = true;
        let showDisabledIcon = true;
        let preFilterCharacterStates = null;
        let userPreferredColumns = 3;

        function initQuickNotes() {
            displayQuickNotes();
        }

        function setGrouping(method) {
            currentGrouping = method;
            const buttons = document.querySelectorAll('#group-series-btn, #group-note-btn, #group-keys-btn, #group-nogroup-btn, #group-kakera-btn, #group-color-btn, #group-gender-btn, #group-roulette-btn, #group-owner-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`group-${method}-btn`).classList.add('active');

            const kakeraRangeContainer = document.getElementById('kakera-range-container');
            const keysRangeContainer = document.getElementById('keys-range-container');
            if (method === 'kakera') {
                kakeraRangeContainer.style.display = 'block';
                keysRangeContainer.style.display = 'none';
            } else if (method === 'keys') {
                kakeraRangeContainer.style.display = 'none';
                keysRangeContainer.style.display = 'block';
            } else {
                kakeraRangeContainer.style.display = 'none';
                keysRangeContainer.style.display = 'none';
            }

            displaySeries();
        }

        function sortGroups(method) {
            if (Object.keys(seriesData).length === 0) {
                return;
            }
            currentSortMethod = method;

            const buttons = document.querySelectorAll('#sort-alpha-btn, #sort-count-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`sort-${method}-btn`).classList.add('active');

            displaySeries();
        }
        function toggleRanking(enabled) {
            isRankingEnabled = enabled;
            document.getElementById('ranking-on-btn').classList.toggle('active', enabled);
            document.getElementById('ranking-off-btn').classList.toggle('active', !enabled);

            if (Object.keys(seriesData).length > 0) {
                displaySeries();
            }
        }
        function changeGridColumns(columns) {
            const grid = document.getElementById('seriesGrid');
            if (grid) {
                grid.style.gridTemplateColumns = `repeat(${columns}, minmax(300px, 1fr))`;
            }

            if (columns > 1) {
                userPreferredColumns = columns;
            }

            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`grid-btn-${i}`);
                if (btn) btn.classList.remove('active');
            }

            const activeBtn = document.getElementById(`grid-btn-${columns}`);
            if (activeBtn) activeBtn.classList.add('active');

            localStorage.setItem('mudaeGridColumns', columns);
        }
        function toggleDeselectedVisibility(shouldShow) {
            showDeselected = shouldShow;
            document.getElementById('deselected-show-btn').classList.toggle('active', shouldShow);
            document.getElementById('deselected-hide-btn').classList.toggle('active', !shouldShow);

            if (Object.keys(seriesData).length > 0) {
                displaySeries();
            }

            saveToLocalStorage();
        }
        function toggleDisabledIconVisibility(shouldShow) {
            showDisabledIcon = shouldShow;
            document.getElementById('disabled-icon-show-btn').classList.toggle('active', shouldShow);
            document.getElementById('disabled-icon-hide-btn').classList.toggle('active', !shouldShow);

            document.querySelector('.container').classList.toggle('hide-disabled-emoji', !shouldShow);

            saveToLocalStorage();
        }
        function displayQuickNotes() {
            const list = document.getElementById('quickNotesList');
            list.innerHTML = '';

            const isColorCode = /^#([0-9a-fA-F]{3}){1,2}$/;

            quickNotes.forEach(function (note, idx) {
                const noteEl = document.createElement('div');
                noteEl.className = 'quick-note';
                noteEl.onclick = function (e) {
                    if (!e.target.classList.contains('quick-note-remove')) {
                        copyToClipboard(note);

                        noteEl.classList.add('copied');

                        setTimeout(function () {
                            noteEl.classList.remove('copied');
                        }, 150);
                    }
                };

                const isColor = isColorCode.test(note);

                if (isColor) {
                    const colorIndicator = document.createElement('div');
                    colorIndicator.className = 'color-indicator';
                    colorIndicator.style.cssText = `background-color: ${note}; width: 12px; height: 12px; border: none;`;
                    noteEl.appendChild(colorIndicator);

                    const noteText = document.createTextNode(note);
                    noteEl.appendChild(noteText);
                } else {
                    const noteText = document.createTextNode(note);
                    noteEl.appendChild(noteText);
                }

                const removeSpan = document.createElement('span');
                removeSpan.className = 'quick-note-remove';
                removeSpan.textContent = 'Ã—';
                removeSpan.title = 'Remove';
                removeSpan.onclick = function (e) {
                    e.stopPropagation();
                    removeQuickNote(idx);
                };

                noteEl.appendChild(document.createTextNode(' '));
                noteEl.appendChild(removeSpan);
                list.appendChild(noteEl);
            });
        }

        function addQuickNote() {
            const input = document.getElementById('newQuickNote');
            const note = input.value.trim();
            if (note && quickNotes.indexOf(note) === -1) {
                quickNotes.push(note);
                displayQuickNotes();
                input.value = '';
            }
            saveToLocalStorage();
        }

        function removeQuickNote(idx) {
            quickNotes.splice(idx, 1);
            displayQuickNotes();
            saveToLocalStorage();
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(function () {
            });
        }

        window.addEventListener('DOMContentLoaded', function () {
            initQuickNotes();
            loadFromLocalStorage();

            document.getElementById('seriesGrid').addEventListener('click', (e) => {
                const target = e.target;
                const action = target.dataset.action;
                const card = target.closest('.character-card');
                const groupCard = target.closest('.series-card');

                if (!action && card) {
                    toggleCharacter(card.dataset.originalSeries, parseInt(card.dataset.originalIndex, 10));
                    return;
                }

                if (card && (action === 'edit-note' || action === 'edit-rank')) {
                    e.stopPropagation();
                    const series = card.dataset.originalSeries;
                    const index = parseInt(card.dataset.originalIndex, 10);
                    const char = seriesData[series].characters[index];
                    target.style.display = 'none';

                    const input = document.createElement('input');
                    input.type = (action === 'edit-rank') ? 'number' : 'text';
                    input.className = (action === 'edit-rank') ? 'rank-input' : 'note-editor-input';
                    input.value = (action === 'edit-rank') ? (char.rank > 0 ? char.rank : '') : char.note;

                    if (action === 'edit-note') {
                        input.style.cssText = 'width: 100%; box-sizing: border-box; font-size: 0.7em; text-align: center; padding: 3px; border: 1px solid #7c3aed; background: #1a1a24; color: #e5e7eb; border-radius: 4px; margin: 0;';
                    }

                    if (action === 'edit-rank') card.prepend(input);
                    else target.parentNode.insertBefore(input, target);

                    input.focus();
                    input.select();

                    const saveAndClose = () => {
                        const newValue = input.value;
                        let needsFullRender = false;

                        if (action === 'edit-rank') {
                            char.rank = parseInt(newValue) > 0 ? parseInt(newValue) : 0;

                            target.textContent = char.rank > 0 ? char.rank : '#';
                        } else {
                            char.note = newValue.trim();

                            if (currentGrouping === 'note') {
                                needsFullRender = true;
                            } else {
                                const hasNote = char.note && char.note.trim() !== '';
                                target.textContent = hasNote ? char.note : 'No note!';
                                target.title = hasNote ? char.note : 'Click to add note';
                                target.style.color = hasNote ? '#9ca3af' : '#dc2626';
                                target.style.fontWeight = hasNote ? 'normal' : 'bold';
                            }
                        }

                        if (input.parentNode) input.parentNode.removeChild(input);
                        target.style.display = '';

                        saveToLocalStorage();

                        if (needsFullRender) {
                            displaySeries();
                        }
                    };
                    input.onblur = saveAndClose;
                    input.onkeydown = (event) => { if (event.key === 'Enter') saveAndClose(); };
                    return;
                }


                if (!groupCard || !action) return;

                const getGroupChars = () => {
                    try {
                        const identifierObjects = JSON.parse(groupCard.dataset.characters);
                        return identifierObjects.map(obj => {
                            const { series, index } = obj;
                            if (seriesData[series] && seriesData[series].characters[index]) {
                                return { ...seriesData[series].characters[index], originalSeries: series, originalIndex: index };
                            }
                            return null;
                        }).filter(Boolean);
                    } catch (e) {
                        console.error('Failed to parse character identifiers:', e);
                        return [];
                    }
                };

                switch (action) {
                    case 'toggle-group':
                    case 'invert-group': {
                        const isToggle = action === 'toggle-group';
                        const allCurrentlyExcluded = getGroupChars().every(c => c.excluded);

                        groupCard.querySelectorAll('.character-card').forEach(cardEl => {
                            const series = cardEl.dataset.originalSeries;
                            const index = parseInt(cardEl.dataset.originalIndex, 10);
                            const originalChar = seriesData[series]?.characters[index];
                            if (!originalChar) return;

                            const newExcludedState = isToggle ? !allCurrentlyExcluded : !originalChar.excluded;
                            if (originalChar.excluded !== newExcludedState) {
                                originalChar.excluded = newExcludedState;
                                cardEl.classList.toggle('excluded', newExcludedState);
                                if (!showDeselected) {
                                    cardEl.classList.toggle('hidden-char', newExcludedState);
                                }
                            }
                        });

                        updateGroupUI(groupCard);
                        break;
                    }

                    case 'sort': {
                        const sortBy = target.dataset.sortBy;
                        let groupCharsData = getGroupChars();

                        const sortFunctions = {
                            'original': (a, b) => a.originalIndex - b.originalIndex, 'az': (a, b) => a.name.localeCompare(b.name),
                            'rank': (a, b) => parseInt(a.globalRank || 999999) - parseInt(b.globalRank || 999999),
                            'kakera': (a, b) => parseInt(b.kakera || 0) - parseInt(a.kakera || 0),
                            'keys': (a, b) => parseInt(b.keys || 0) - parseInt(a.keys || 0)
                        };

                        groupCharsData.sort(sortFunctions[sortBy]);

                        if (isRankingEnabled) {
                            groupCharsData.forEach((char, index) => {
                                seriesData[char.originalSeries].characters[char.originalIndex].rank = index + 1;
                            });
                        }

                        const charList = groupCard.querySelector('.characters-list');
                        charList.innerHTML = groupCharsData.map(char => createCharacterCardHTML(char)).join('');

                        groupCard.querySelectorAll('[data-action="sort"]').forEach(btn => btn.classList.remove('active'));
                        target.classList.add('active');
                        break;
                    }

                    case 'bulk-note':
                    case 'bulk-color': {
                        const isNote = action === 'bulk-note';
                        const applyTo = target.dataset.target;
                        const input = target.closest('.bulk-apply-group').querySelector('.note-input');
                        const newValue = input.value;

                        if (!isNote && newValue.trim() !== "" && !/^#([0-9a-fA-F]{3}){1,2}$/.test(newValue)) {
                            showMessage('Invalid hex color format. Use #RRGGBB.', 'error');
                            return;
                        }

                        getGroupChars().forEach(char => {
                            const applies = (applyTo === 'all') || (applyTo === 'selected' && !char.excluded);
                            if (applies) {
                                const originalChar = seriesData[char.originalSeries].characters[char.originalIndex];
                                if (isNote) originalChar.note = newValue;
                                else originalChar.color = newValue.trim();
                            }
                        });

                        input.value = '';

                        if ((isNote && currentGrouping === 'note') || (!isNote && currentGrouping === 'color')) {
                            displaySeries();
                        } else {
                            const charList = groupCard.querySelector('.characters-list');
                            charList.innerHTML = getGroupChars().map(char => createCharacterCardHTML(char)).join('');
                        }
                        break;
                    }
                }

                updateStats();
                saveToLocalStorage();
            });
        });

        function parseInput() {
            const input = document.getElementById('input').value.trim();

            if (!input.trim()) {
                return;
            }

            seriesData = {};
            const lines = input.split('\n');
            let currentSeries = null;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (!line) continue;

                const seriesMatch = line.match(/^(.+?)\s*-\s*(\d+)\/(\d+)$/);
                if (seriesMatch) {
                    currentSeries = seriesMatch[1].trim();
                    seriesData[currentSeries] = {
                        total: parseInt(seriesMatch[3]),
                        owned: parseInt(seriesMatch[2]),
                        characters: [],
                        note: ''
                    };
                } else if (currentSeries) {
                    const charMatch = line.match(/^(.+?)\s+-\s+(https?:\/\/.+)$/);
                    if (charMatch) {
                        let fullInfo = charMatch[1].trim();
                        const imageUrl = charMatch[2].trim();

                        let owner = '';
                        const ownerMatch = fullInfo.match(/ðŸ’ž\s*=>\s+(\S+)/);
                        if (ownerMatch) {
                            owner = ownerMatch[1].trim();
                            fullInfo = fullInfo.replace(/ðŸ’ž\s*=>\s+\S+\s*/, '');
                        }

                        fullInfo = fullInfo.replace(/\(\s*\$(?:toggle(?:western|irl)|serverdisable)\s*\)\s*Â·?\s*/g, '');

                        let kakera = '';
                        let keys = '';
                        let color = '';
                        let note = '';
                        let cleanName = '';
                        let isDisabled = false;
                        let globalRank = '';

                        const globalRankMatch = fullInfo.match(/^#([\d,]+)\s+-\s+/);
                        if (globalRankMatch) {
                            globalRank = globalRankMatch[1].replace(/,/g, '');
                            fullInfo = fullInfo.substring(globalRankMatch[0].length).trim();
                        }

                        const kakeraMatch = fullInfo.match(/([\d,]+)\s*ka\s*$/);
                        if (kakeraMatch) {
                            kakera = kakeraMatch[1].replace(/,/g, '');
                            fullInfo = fullInfo.substring(0, kakeraMatch.index).trim();
                        }

                        let mudaeTags = [];
                        const tagsMatch = fullInfo.match(/\(\s*\$[^)]+\s*\)/);
                        if (tagsMatch) {
                            const tagsString = tagsMatch[0];
                            const rawTags = tagsString.match(/\$([a-zA-Z]{2})/g);
                            if (rawTags) {
                                mudaeTags = rawTags.map(tag => tag.substring(1));
                            }
                            fullInfo = fullInfo.replace(tagsString, '').trim().replace(/Â·\s*Â·/g, 'Â·').trim();
                        }

                        let namePart = fullInfo;
                        let metaPart = '';
                        const metaSeparatorIndex = fullInfo.lastIndexOf('Â·');
                        if (metaSeparatorIndex !== -1) {
                            namePart = fullInfo.substring(0, metaSeparatorIndex).trim();
                            metaPart = fullInfo.substring(metaSeparatorIndex + 1).trim();
                        }

                        if (metaPart) {
                            const colorMatch = metaPart.match(/\(#([0-9a-fA-F]{6})\)/);
                            if (colorMatch) {
                                color = '#' + colorMatch[1];
                            }

                            const keysMatch = metaPart.match(/\((\d+)\)/);
                            if (keysMatch) {
                                keys = keysMatch[1];
                            }
                        }

                        if (namePart.includes('ðŸš«')) {
                            isDisabled = true;
                            namePart = namePart.replace('ðŸš«', '').trim();
                        }

                        const pipeIndex = namePart.indexOf('|');
                        if (pipeIndex !== -1) {
                            cleanName = namePart.substring(0, pipeIndex).trim();
                            note = namePart.substring(pipeIndex + 1).trim();
                        } else {
                            cleanName = namePart;
                        }

                        seriesData[currentSeries].characters.push({
                            name: cleanName,
                            displayName: cleanName,
                            image: imageUrl,
                            excluded: false,
                            kakera: kakera,
                            keys: keys,
                            note: note,
                            color: color,
                            isDisabled: isDisabled,
                            rank: 0,
                            globalRank: globalRank,
                            mudaeTags: mudaeTags,
                            owner: owner
                        });
                    }
                }
            }

            if (Object.keys(seriesData).length === 0) {
                showMessage('Parsing failed. Please ensure your input format is correct and contains at least one series.', 'error');
                return;
            }

            populateOwnerFilter();
            displaySeries();
            updateStats();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('generateColorBtn').disabled = false;
            document.getElementById('playerStatsBtn').disabled = false;
            saveToLocalStorage();
        }

        function createCharacterCardHTML(char) {
            let classNames = ['character-card'];
            if (char.excluded) classNames.push('excluded');
            if (char.isDisabled) classNames.push('permanently-disabled');
            if (char.excluded && !showDeselected) classNames.push('hidden-char');

            const colorCode = char.color || '#670d08';
            const hasNote = char.note && char.note.trim() !== '';

            const genders = new Set();
            if (char.mudaeTags) {
                char.mudaeTags.forEach(tag => {
                    const gender = tag[0].toLowerCase();
                    if (gender === 'w' || gender === 'h') genders.add(gender);
                });
            }
            const hasWaifu = genders.has('w');
            const hasHusbando = genders.has('h');

            let genderBarHTML = '';
            if (hasWaifu || hasHusbando) {
                genderBarHTML += '<div style="display: flex; text-align: center; font-size: 0.65em; font-weight: 600;">';
                if (hasWaifu) genderBarHTML += '<div style="flex: 1; padding: 2px 0; background-color: #ff8f8f; color: #0a0a0f;" title="Waifu">Waifu</div>';
                if (hasHusbando) genderBarHTML += '<div style="flex: 1; padding: 2px 0; background-color: #8fafff; color: #0a0a0f;" title="Husbando">Husbando</div>';
                genderBarHTML += '</div>';
            }

            const roulettes = new Set();
            if (char.mudaeTags) {
                char.mudaeTags.forEach(tag => {
                    if (tag.length > 1) {
                        const roulette = tag[1].toLowerCase();
                        if (roulette === 'a' || roulette === 'g') roulettes.add(roulette);
                    }
                });
            }
            const hasAnimanga = roulettes.has('a');
            const hasGame = roulettes.has('g');

            let rouletteBarHTML = '<div style="display: flex; text-align: center; font-size: 0.65em; font-weight: 600;">';
            if (hasAnimanga) rouletteBarHTML += '<div style="flex: 1; padding: 2px 0; background-color: #a78bfa; color: #0a0a0f;" title="Animanga">Animanga</div>';
            if (hasGame) rouletteBarHTML += '<div style="flex: 1; padding: 2px 0; background-color: #ffcb70; color: #0a0a0f;" title="Game">Game</div>';
            if (!hasAnimanga && !hasGame) rouletteBarHTML += '<div style="flex: 1; padding: 2px 0; background-color: #1f1f2e; color: #6b7280; font-style: italic;" title="Unknown Roulette">Unknown</div>';
            rouletteBarHTML += '</div>';

            return `<div class="${classNames.join(' ')}" data-original-series="${char.originalSeries}" data-original-index="${char.originalIndex}" style="--card-color: ${colorCode};">
${isRankingEnabled ? `<div class="character-rank-badge" data-action="edit-rank">${char.rank > 0 ? char.rank : '#'}</div>` : ''}
<img src="${char.image}" alt="${char.name}" loading="lazy" onerror="handleImageError(this)">
<div class="character-info">
<div class="character-name" title="${char.name}">${char.name}</div>
${(() => {
                    if (!char.owner) return '';
                    const letter = char.owner[0].toUpperCase();
                    const hue = ((letter.charCodeAt(0) - 65) * 360) / 26;
                    const color = `hsl(${hue}, 80%, 65%)`;
                    return `<div class="character-owner-badge" 
                 title="Owner: ${escapeHTML(char.owner)}" 
                 style="color: ${color}; border-color: ${color};">
                ${escapeHTML(char.owner)}
            </div>`;
                })()}
<div class="character-note" data-action="edit-note" title="${hasNote ? char.note : 'Click to add note'}" style="background: #13131a; padding: 4px; font-size: 0.7em; color: ${hasNote ? '#9ca3af' : '#dc2626; font-weight: bold'}; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; border-radius: 4px;">${hasNote ? char.note : 'No note!'}</div>
<div class="character-stats">
<div class="stat-badge"><div class="stat-badge-label">Rank</div><div class="stat-badge-value">${char.globalRank ? '#' + char.globalRank : '#?'}</div></div>
<div class="stat-badge"><div class="stat-badge-label">Ka</div><div class="stat-badge-value">${char.kakera || '?'}</div></div>
<div class="stat-badge"><div class="stat-badge-label">Keys</div><div class="stat-badge-value">${char.keys || '?'}</div></div>
</div>
</div>
${genderBarHTML}
${rouletteBarHTML}
</div>`;
        }

        function selectAllCharacters() {
            if (Object.keys(seriesData).length === 0) {
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    char.excluded = false;
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function deselectAllCharacters() {
            if (Object.keys(seriesData).length === 0) {
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    char.excluded = true;
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function selectDisabledCharacters() {
            if (Object.keys(seriesData).length === 0) {
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    if (char.isDisabled) {
                        char.excluded = false;
                    }
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function deselectDisabledCharacters() {
            if (Object.keys(seriesData).length === 0) {
                return;
            }

            for (let seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(function (char) {
                    if (char.isDisabled) {
                        char.excluded = true;
                    }
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function displaySeries() {
            const grid = document.getElementById('seriesGrid');
            grid.innerHTML = '';
            if (Object.keys(seriesData).length === 0) return;

            const groups = {};
            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach((char, idx) => {
                    let groupKey;
                    switch (currentGrouping) {
                        case 'note':
                            groupKey = char.note.trim();
                            break;
                        case 'keys':
                            const keysRangeSize = Math.max(1, parseInt(document.getElementById('keys-range-input').value) || 1);
                            const charKeys = parseInt(char.keys) || 0;
                            const keysLowerBound = Math.floor(charKeys / keysRangeSize) * keysRangeSize;
                            const keysUpperBound = keysLowerBound + keysRangeSize - 1;
                            groupKey = `${keysLowerBound} - ${keysUpperBound} Keys`;
                            break;
                        case 'color':
                            groupKey = char.color.trim().toUpperCase() || '#670D08';
                            break;
                        case 'nogroup': groupKey = 'All Characters'; break;
                        case 'kakera':
                            const rangeSize = Math.max(1, parseInt(document.getElementById('kakera-range-input').value) || 1000);
                            const charKakera = parseInt(char.kakera) || 0;
                            const lowerBound = Math.floor(charKakera / rangeSize) * rangeSize;
                            const upperBound = lowerBound + rangeSize - 1;
                            groupKey = `${lowerBound} - ${upperBound} ka`;
                            break;
                        case 'gender':
                            const genders = new Set();
                            if (char.mudaeTags) {
                                char.mudaeTags.forEach(tag => {
                                    const gender = tag[0].toLowerCase();
                                    if (gender === 'w' || gender === 'h') genders.add(gender);
                                });
                            }
                            if (genders.has('w') && genders.has('h')) groupKey = 'Waifu & Husbando';
                            else if (genders.has('w')) groupKey = 'Waifu';
                            else if (genders.has('h')) groupKey = 'Husbando';
                            else groupKey = 'Genderless / Other';
                            break;
                        case 'roulette':
                            const roulettes = new Set();
                            if (char.mudaeTags) {
                                char.mudaeTags.forEach(tag => {
                                    if (tag.length > 1) {
                                        const roulette = tag[1].toLowerCase();
                                        if (roulette === 'a' || roulette === 'g') roulettes.add(roulette);
                                    }
                                });
                            }
                            if (roulettes.has('a') && roulettes.has('g')) groupKey = 'Animanga & Game';
                            else if (roulettes.has('a')) groupKey = 'Animanga';
                            else if (roulettes.has('g')) groupKey = 'Game';
                            else groupKey = 'Unknown Roulette';
                            break;
                        case 'owner':
                            groupKey = char.owner ? char.owner : 'Unassigned';
                            break;
                        case 'series':
                            groupKey = seriesName;
                            break;
                        default:
                            groupKey = seriesName;
                            break;
                    }
                    if (!groups[groupKey]) {
                        groups[groupKey] = { characters: [], sort: 'original' };
                    }
                    groups[groupKey].characters.push({ ...char, originalSeries: seriesName, originalIndex: idx });
                });
            }

            const sortedGroupEntries = Object.entries(groups).sort((a, b) => {
                const [keyA, dataA] = a; const [keyB, dataB] = b;
                if (currentSortMethod === 'count') return dataB.characters.length - dataA.characters.length;
                if (currentGrouping === 'kakera') {
                    const valA = parseInt(keyA.split(' ')[0]); const valB = parseInt(keyB.split(' ')[0]);
                    return valA - valB;
                }
                return keyA.localeCompare(keyB);
            });

            let finalHTML = '';
            for (const [groupName, data] of sortedGroupEntries) {
                const includedCount = data.characters.filter(c => !c.excluded).length;
                const allExcluded = data.characters.every(c => c.excluded);
                const charIdentifiers = JSON.stringify(data.characters.map(c => ({
                    series: c.originalSeries,
                    index: c.originalIndex
                })));

                let displayName = groupName;
                if (currentGrouping === 'note' && groupName === '') {
                    displayName = '(No Note)';
                } else if (currentGrouping === 'color' && groupName.toUpperCase() === '#670D08') {
                    displayName = '(No Color)';
                }

                if (isRankingEnabled && data.characters.every(c => c.rank === 0)) {
                    data.characters.forEach((char, index) => char.rank = index + 1);
                }
                data.characters.sort((a, b) => a.rank - b.rank);

                const charactersHTML = data.characters.map(char => createCharacterCardHTML(char)).join('');

                const groupCardHTML = `<div class="series-card" data-group-name="${escapeHTML(groupName)}" data-characters="${escapeHTML(charIdentifiers)}">
<div class="series-header">
<div class="series-title" title="${displayName}">${displayName}</div>
<div class="series-count">${includedCount}/${data.characters.length}</div>
</div>
<div class="card-controls">
<div class="controls-row main-actions">
<div style="display: flex; gap: 8px;">
<button class="btn btn-sm ${allExcluded ? 'btn-danger' : 'btn-primary'}" data-action="toggle-group">${allExcluded ? 'Enable All' : 'Disable All'}</button>
<button class="btn btn-sm btn-secondary" data-action="invert-group">Invert</button>
</div>
<div class="sort-buttons">
<span class="sort-label">Sort:</span>
<button data-action="sort" data-sort-by="original" class="btn btn-sm active">Original</button>
<button data-action="sort" data-sort-by="az" class="btn btn-sm">A-Z</button>
<button data-action="sort" data-sort-by="rank" class="btn btn-sm">Rank</button>
<button data-action="sort" data-sort-by="kakera" class="btn btn-sm">Kakera</button>
<button data-action="sort" data-sort-by="keys" class="btn btn-sm">Keys</button>
</div>
</div>
<div class="controls-row">
<div class="bulk-apply-group">
<input type="text" class="note-input" placeholder="Apply note...">
<div class="apply-btn-group">
<button data-action="bulk-note" data-target="all" class="btn">All</button>
<button data-action="bulk-note" data-target="selected" class="btn">Selected</button>
</div>
</div>
<div class="bulk-apply-group">
<input type="text" class="note-input" placeholder="Apply color...">
<div class="apply-btn-group">
<button data-action="bulk-color" data-target="all" class="btn">All</button>
<button data-action="bulk-color" data-target="selected" class="btn">Selected</button>
</div>
</div>
</div>
</div>
<div class="characters-list">${charactersHTML}</div>
</div>`;

                const hasVisibleChars = data.characters.some(c => !c.excluded);
                if (showDeselected || hasVisibleChars) {
                    finalHTML += groupCardHTML;
                }
            }
            grid.innerHTML = finalHTML;

            const groupCount = sortedGroupEntries.length;
            if (groupCount === 1) {
                changeGridColumns(1);
            } else if (groupCount > 1 && grid.style.gridTemplateColumns.includes('repeat(1,')) {
                changeGridColumns(userPreferredColumns);
            }
        }

        function toggleCharacter(seriesName, charIdx) {
            if (!seriesData[seriesName] || !seriesData[seriesName].characters[charIdx]) return;

            const char = seriesData[seriesName].characters[charIdx];
            char.excluded = !char.excluded;

            const cardElement = document.querySelector(`.character-card[data-original-series="${seriesName}"][data-original-index="${charIdx}"]`);
            if (cardElement) {
                cardElement.classList.toggle('excluded', char.excluded);

                if (char.excluded && !showDeselected) {
                    cardElement.classList.add('hidden-char');
                } else {
                    cardElement.classList.remove('hidden-char');
                }

                const groupCard = cardElement.closest('.series-card');
                if (groupCard) {
                    updateGroupUI(groupCard);
                }
            }

            updateStats();
            saveToLocalStorage();
        }

        function updateGroupUI(groupCard) {
            let groupChars = [];
            try {
                const identifierObjects = JSON.parse(groupCard.dataset.characters);
                groupChars = identifierObjects.map(obj => {
                    const { series, index } = obj;
                    if (seriesData[series] && seriesData[series].characters[index]) {
                        return seriesData[series].characters[index];
                    }
                    return null;
                }).filter(Boolean);
            } catch (e) {
                console.error('Failed to parse group characters in updateGroupUI:', e);
                return;
            }

            const includedCount = groupChars.filter(c => !c.excluded).length;
            const allExcluded = includedCount === 0;

            const countEl = groupCard.querySelector('.series-count');
            if (countEl) {
                countEl.textContent = `${includedCount}/${groupChars.length}`;
            }

            const toggleBtn = groupCard.querySelector('[data-action="toggle-group"]');
            if (toggleBtn) {
                toggleBtn.textContent = allExcluded ? 'Enable All' : 'Disable All';
                toggleBtn.classList.toggle('disabled', allExcluded);
            }

            if (!showDeselected) {
                groupCard.style.display = includedCount > 0 ? '' : 'none';
            }
        }

        function toggleGroup(charactersInGroup, event) {
            if (!charactersInGroup || charactersInGroup.length === 0) return;

            const allExcluded = charactersInGroup.every(c => seriesData[c.originalSeries].characters[c.originalIndex].excluded);
            const shouldExclude = !allExcluded;

            charactersInGroup.forEach(char => {
                seriesData[char.originalSeries].characters[char.originalIndex].excluded = shouldExclude;
            });

            const button = event.currentTarget;
            const groupCard = button.closest('.series-card');

            if (groupCard) {
                button.classList.toggle('disabled', shouldExclude);
                button.textContent = shouldExclude ? 'Enable All' : 'Disable All';

                const charCardsInGroup = groupCard.querySelectorAll('.character-card');
                charCardsInGroup.forEach(card => {
                    card.classList.toggle('excluded', shouldExclude);
                    if (!showDeselected) {
                        card.classList.toggle('hidden-char', shouldExclude);
                    }
                });

                if (!showDeselected) {
                    groupCard.style.display = shouldExclude ? 'none' : '';
                }

                const countEl = groupCard.querySelector('.series-count');
                const total = groupCard.dataset.totalChars;
                if (countEl && total) {
                    const newCount = shouldExclude ? 0 : total;
                    countEl.textContent = `${newCount}/${total}`;
                }
            }

            updateStats();
            saveToLocalStorage();
        }

        function invertGroup(charactersInGroup, event) {
            if (!charactersInGroup || charactersInGroup.length === 0) return;

            charactersInGroup.forEach(char => {
                const charData = seriesData[char.originalSeries].characters[char.originalIndex];
                charData.excluded = !charData.excluded;
            });

            const button = event.currentTarget;
            const groupCard = button.closest('.series-card');

            if (groupCard) {
                const charCardsInGroup = groupCard.querySelectorAll('.character-card');
                charCardsInGroup.forEach(card => {
                    const seriesName = card.dataset.originalSeries;
                    const charIndex = parseInt(card.dataset.originalIndex, 10);
                    const charData = seriesData[seriesName].characters[charIndex];
                    card.classList.toggle('excluded', charData.excluded);
                    if (!showDeselected) {
                        card.classList.toggle('hidden-char', charData.excluded);
                    }
                });

                const includedCount = charactersInGroup.filter(c => !seriesData[c.originalSeries].characters[c.originalIndex].excluded).length;

                if (!showDeselected) {
                    groupCard.style.display = includedCount === 0 ? 'none' : '';
                }

                const countEl = groupCard.querySelector('.series-count');
                const total = groupCard.dataset.totalChars;
                if (countEl && total) {
                    countEl.textContent = `${includedCount}/${total}`;
                }

                const allExcludedInGroup = includedCount === 0;
                const toggleBtn = groupCard.querySelector('.series-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.classList.toggle('disabled', allExcludedInGroup);
                    toggleBtn.textContent = allExcludedInGroup ? 'Enable All' : 'Disable All';
                }
            }

            updateStats();
            saveToLocalStorage();
        }

        function updateStats() {
            const totalSeries = Object.keys(seriesData).length;
            let totalChars = 0;
            let includedChars = 0;

            for (let key in seriesData) {
                const data = seriesData[key];
                totalChars += data.characters.length;
                includedChars += data.characters.filter(function (c) { return !c.excluded; }).length;
            }

            const stats = document.getElementById('stats');
            stats.innerHTML = '<div class="stats">' +
                '<div class="stat-item">' +
                '<div class="stat-label">Total Series</div>' +
                '<div class="stat-value">' + totalSeries + '</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="stat-label">Total Characters</div>' +
                '<div class="stat-value">' + totalChars + '</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="stat-label">Included Characters</div>' +
                '<div class="stat-value">' + includedChars + '</div>' +
                '</div>' +
                '</div>';
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        function generateNoteCommands() {
            const commandsDiv = document.getElementById('commands');
            commandsDiv.innerHTML = `
 <div class="commands-section">
  <h2 style="display: flex; justify-content: space-between; align-items: center;">
   Generated Note Commands
   <button onclick="scrollToTop()" class="btn btn-sm btn-primary" style="font-size: 0.7em; padding: 6px 12px;">Go to Top â†‘</button>
  </h2>
 </div>`;
            const container = commandsDiv.querySelector('.commands-section');

            const commandsByNote = {};
            let totalSelectedCharacters = 0;

            const allSelectedCards = document.querySelectorAll('#seriesGrid .character-card:not(.excluded)');

            const orderedSelectedChars = Array.from(allSelectedCards).map(card => {
                const seriesName = card.dataset.originalSeries;
                const charIndex = parseInt(card.dataset.originalIndex, 10);
                return seriesData[seriesName].characters[charIndex];
            });

            for (const char of orderedSelectedChars) {
                if (!char.excluded) {
                    totalSelectedCharacters++;
                    const note = char.note ? char.note.trim() : '';
                    if (!commandsByNote[note]) {
                        commandsByNote[note] = [];
                    }
                    commandsByNote[note].push(char);
                }
            }

            const sortedNotes = Object.keys(commandsByNote).sort((a, b) => a.localeCompare(b));

            for (const note of sortedNotes) {
                const charsWithThisNote = commandsByNote[note];
                const allCharsNames = charsWithThisNote.map(c => c.name);

                let commandParts = [];
                const commandPrefix = '$n ';
                const commandSuffix = note ? ` $ ${note}` : '';
                let currentCharacterString = '';

                for (const charName of allCharsNames) {
                    const separator = currentCharacterString ? '$' : '';
                    const potentialNextString = currentCharacterString + separator + charName;

                    if ((commandPrefix.length + potentialNextString.length + commandSuffix.length) > 1990) {
                        const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                        commandParts.push(finalCommand);
                        currentCharacterString = charName;
                    } else {
                        currentCharacterString = potentialNextString;
                    }
                }

                if (currentCharacterString) {
                    const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                    commandParts.push(finalCommand);
                }

                commandParts.forEach((command, idx) => {
                    const commandItem = document.createElement('div');
                    commandItem.className = 'command-item';

                    let headerText = `Note: ${note || 'None'}`;
                    headerText += ` - ${allCharsNames.length} character${allCharsNames.length > 1 ? 's' : ''}`;
                    if (commandParts.length > 1) {
                        headerText += ` (Part ${idx + 1}/${commandParts.length})`;
                    }

                    commandItem.innerHTML = `
      <div class="command-header">
       <div class="command-series">${headerText}</div>
      </div>
      <div class="command-text">${command}</div>
      <button class="btn btn-sm btn-primary" onclick="copyCommand(this, \`${command.replace(/`/g, '\\`')}\`)">Copy Command</button>
     `;
                    container.appendChild(commandItem);
                });
            }

            if (totalSelectedCharacters === 0) {
                const p = document.createElement('p');
                p.style.color = '#6b7280';
                p.style.padding = '20px';
                p.textContent = 'No commands to generate. Please select at least one character.';
                container.appendChild(p);
            }

            const commandsContainer = document.getElementById('commands').querySelector('.command-item');
            if (commandsContainer) {
                document.getElementById('goToCommandsBtn').style.display = 'inline-block';
            } else {
                document.getElementById('goToCommandsBtn').style.display = 'none';
            }
        }

        function generateColorCommands() {
            const commandsDiv = document.getElementById('commands');
            commandsDiv.innerHTML = `
 <div class="commands-section">
  <h2 style="display: flex; justify-content: space-between; align-items: center;">
   Generated Color Commands ($ec)
   <button onclick="scrollToTop()" class="btn btn-sm btn-primary" style="font-size: 0.7em; padding: 6px 12px;">Go to Top â†‘</button>
  </h2>
 </div>`;
            const container = commandsDiv.querySelector('.commands-section');

            const commandsByColor = {};
            let totalSelectedCharacters = 0;

            const allSelectedCards = document.querySelectorAll('#seriesGrid .character-card:not(.excluded)');

            const orderedSelectedChars = Array.from(allSelectedCards).map(card => {
                const seriesName = card.dataset.originalSeries;
                const charIndex = parseInt(card.dataset.originalIndex, 10);
                return seriesData[seriesName].characters[charIndex];
            });

            for (const char of orderedSelectedChars) {
                if (!char.excluded && char.color) {
                    totalSelectedCharacters++;
                    const color = char.color.trim().toLowerCase();
                    if (!commandsByColor[color]) {
                        commandsByColor[color] = [];
                    }
                    commandsByColor[color].push(char);
                }
            }

            const sortedColors = Object.keys(commandsByColor).sort((a, b) => a.localeCompare(b));

            for (const color of sortedColors) {
                const charsWithThisColor = commandsByColor[color];
                const allCharsNames = charsWithThisColor.map(c => c.name);

                let commandParts = [];
                const commandPrefix = '$ec ';
                const commandSuffix = ` $ ${color}`;
                let currentCharacterString = '';

                for (const charName of allCharsNames) {
                    const separator = currentCharacterString ? '$' : '';
                    const potentialNextString = currentCharacterString + separator + charName;

                    if ((commandPrefix.length + potentialNextString.length + commandSuffix.length) > 1990) {
                        const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                        commandParts.push(finalCommand);
                        currentCharacterString = charName;
                    } else {
                        currentCharacterString = potentialNextString;
                    }
                }

                if (currentCharacterString) {
                    const finalCommand = commandPrefix + currentCharacterString + commandSuffix;
                    commandParts.push(finalCommand);
                }

                commandParts.forEach((command, idx) => {
                    const commandItem = document.createElement('div');
                    commandItem.className = 'command-item';

                    let headerText = `Color: ${color}`;
                    headerText += ` - ${charsWithThisColor.length} character${charsWithThisColor.length > 1 ? 's' : ''}`;
                    if (commandParts.length > 1) {
                        headerText += ` (Part ${idx + 1}/${commandParts.length})`;
                    }

                    commandItem.innerHTML = `
      <div class="command-header">
       <div class="command-series">${headerText}</div>
      </div>
      <div class="command-text">${command}</div>
      <button class="btn btn-sm btn-primary" onclick="copyCommand(this, \`${command.replace(/`/g, '\\`')}\`)">Copy Command</button>
     `;
                    container.appendChild(commandItem);
                });
            }

            if (totalSelectedCharacters === 0) {
                const p = document.createElement('p');
                p.style.color = '#6b7280';
                p.style.padding = '20px';
                p.textContent = 'No characters with a custom color selected to generate commands.';
                container.appendChild(p);
            }

            const commandsContainer = document.getElementById('commands').querySelector('.command-item');
            if (commandsContainer) {
                document.getElementById('goToCommandsBtn').style.display = 'inline-block';
            } else {
                document.getElementById('goToCommandsBtn').style.display = 'none';
            }
        }

        function scrollToCommands() {
            const commandsSection = document.getElementById('commands');
            if (commandsSection) {
                commandsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function copyCommand(btn, command) {
            navigator.clipboard.writeText(command).then(function () {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#28a745';
                setTimeout(function () {
                    btn.textContent = originalText;
                    btn.style.background = '#7c3aed';
                }, 2000);
            });
        }

        function clearAll() {
            if (Object.keys(seriesData).length > 0) {
                if (!confirm('This will clear all data')) return;
            }

            seriesData = {};
            currentGrouping = 'series';
            currentSortMethod = 'count';

            document.getElementById('input').value = '';
            document.getElementById('seriesGrid').innerHTML = '';
            document.getElementById('commands').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
            document.getElementById('message').innerHTML = '';
            document.getElementById('message').className = 'empty';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('playerStatsBtn').disabled = true;
            document.getElementById('generateColorBtn').disabled = true;
            document.getElementById('goToCommandsBtn').style.display = 'none';

            const groupButtons = document.querySelectorAll('#group-series-btn, #group-note-btn, #group-keys-btn, #group-nogroup-btn, #group-kakera-btn, #group-color-btn, #group-gender-btn, #group-roulette-btn, #group-owner-btn');
            groupButtons.forEach(btn => btn.classList.remove('active'));
            document.getElementById('group-series-btn').classList.add('active');
            document.getElementById('kakera-range-container').style.display = 'none';
            document.getElementById('keys-range-container').style.display = 'none';

            const sortButtons = document.querySelectorAll('#sort-alpha-btn, #sort-count-btn');
            sortButtons.forEach(btn => btn.classList.remove('active'));
            document.getElementById('sort-count-btn').classList.add('active');

            document.getElementById('disabled-icon-show-btn').classList.add('active');
            document.getElementById('disabled-icon-hide-btn').classList.remove('active');
            document.querySelector('.container').classList.remove('hide-disabled-emoji');

            localStorage.removeItem('mudaeSeriesData');
            localStorage.removeItem('mudaeQuickNotes');
            localStorage.removeItem('mudaeShowDisabledIcon');
        }

        function applyFilter() {
            if (Object.keys(seriesData).length === 0) return;

            if (preFilterCharacterStates === null) {
                preFilterCharacterStates = {};
                for (const seriesName in seriesData) {
                    preFilterCharacterStates[seriesName] = seriesData[seriesName].characters.map(char => char.excluded);
                }
            }

            const minKakera = parseInt(document.getElementById('min-kakera').value) || 0;
            const maxKakera = parseInt(document.getElementById('max-kakera').value) || Infinity;
            const minKeys = parseInt(document.getElementById('min-keys').value) || 0;
            const maxKeys = parseInt(document.getElementById('max-keys').value) || Infinity;
            const genderFilter = document.getElementById('filter-gender').value;
            const rouletteFilter = document.getElementById('filter-roulette').value;
            const ownerFilter = document.getElementById('filter-owner').value;

            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach((char) => {
                    const charKakera = parseInt(char.kakera) || 0;
                    const charKeys = parseInt(char.keys) || 0;

                    const matchesKakera = charKakera >= minKakera && charKakera <= maxKakera;
                    const matchesKeys = charKeys >= minKeys && charKeys <= maxKeys;

                    const genders = new Set();
                    if (char.mudaeTags) {
                        char.mudaeTags.forEach(tag => {
                            const gender = tag[0].toLowerCase();
                            if (gender === 'w' || gender === 'h') genders.add(gender);
                        });
                    }
                    const hasWaifu = genders.has('w');
                    const hasHusbando = genders.has('h');

                    let matchesGender = false;
                    switch (genderFilter) {
                        case 'any': matchesGender = true; break;
                        case 'has_waifu': matchesGender = hasWaifu; break;
                        case 'has_husbando': matchesGender = hasHusbando; break;
                        case 'only_waifu': matchesGender = hasWaifu && !hasHusbando; break;
                        case 'only_husbando': matchesGender = hasHusbando && !hasWaifu; break;
                        case 'genderless': matchesGender = !hasWaifu && !hasHusbando; break;
                        default: matchesGender = true;
                    }

                    const roulettes = new Set();
                    if (char.mudaeTags) {
                        char.mudaeTags.forEach(tag => {
                            if (tag.length > 1) {
                                const roulette = tag[1].toLowerCase();
                                if (roulette === 'a' || roulette === 'g') roulettes.add(roulette);
                            }
                        });
                    }
                    const hasAnimanga = roulettes.has('a');
                    const hasGame = roulettes.has('g');

                    let matchesRoulette = false;
                    switch (rouletteFilter) {
                        case 'any': matchesRoulette = true; break;
                        case 'has_animanga': matchesRoulette = hasAnimanga; break;
                        case 'has_game': matchesRoulette = hasGame; break;
                        case 'only_animanga': matchesRoulette = hasAnimanga && !hasGame; break;
                        case 'only_game': matchesRoulette = hasGame && !hasAnimanga; break;
                        case 'both': matchesRoulette = hasAnimanga && hasGame; break;
                        default: matchesRoulette = true;
                    }
                    let matchesOwner = (ownerFilter === 'any') || (char.owner === ownerFilter);

                    const matchesFilter = matchesKakera && matchesKeys && matchesGender && matchesRoulette && matchesOwner;

                    if (!matchesFilter) {
                        char.excluded = true;
                    }
                });
            }

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function clearFilter() {
            document.getElementById('min-kakera').value = '';
            document.getElementById('max-kakera').value = '';
            document.getElementById('min-keys').value = '';
            document.getElementById('max-keys').value = '';
            document.getElementById('filter-gender').value = 'any';
            document.getElementById('filter-roulette').value = 'any';
            document.getElementById('filter-owner').value = 'any';

            if (preFilterCharacterStates === null) {
                return;
            }

            for (const seriesName in preFilterCharacterStates) {
                if (seriesData[seriesName]) {
                    preFilterCharacterStates[seriesName].forEach((wasExcluded, charIndex) => {
                        if (seriesData[seriesName].characters[charIndex]) {
                            seriesData[seriesName].characters[charIndex].excluded = wasExcluded;
                        }
                    });
                }
            }

            preFilterCharacterStates = null;

            displaySeries();
            updateStats();
            saveToLocalStorage();
        }

        function populateOwnerFilter() {
            const owners = new Set();
            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(char => {
                    if (char.owner) owners.add(char.owner);
                });
            }

            const filterOwner = document.getElementById('filter-owner');
            const currentVal = filterOwner.value;
            filterOwner.innerHTML = '<option value="any">Any</option>';

            Array.from(owners).sort().forEach(owner => {
                const option = document.createElement('option');
                option.value = owner;
                option.textContent = owner;
                filterOwner.appendChild(option);
            });

            filterOwner.value = currentVal;
        }

        function escapeHTML(str) {
            if (typeof str !== 'string') return str;
            return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = text;
            setTimeout(function () {
                messageDiv.innerHTML = '';
                messageDiv.className = 'empty-message'
            }, 5000);
        }

        function handleImageError(imgElement) {
            imgElement.style.display = 'none';
            const placeholder = document.createElement('div');
            placeholder.style.cssText = 'width: 135px; height: 210px; background: #2a2a3a; display: flex; align-items: center; justify-content: center; color: #6b7280; font-size: 0.8em; text-align: center; padding: 10px;';
            placeholder.textContent = 'No Image Available';
            imgElement.parentNode.insertBefore(placeholder, imgElement);
        }

        function saveToLocalStorage() {
            try {
                localStorage.setItem('mudaeSeriesData', JSON.stringify(seriesData));
                localStorage.setItem('mudaeQuickNotes', JSON.stringify(quickNotes));
                localStorage.setItem('mudaeRankingEnabled', JSON.stringify(isRankingEnabled));
                localStorage.setItem('mudaeShowDeselected', JSON.stringify(showDeselected));
                localStorage.setItem('mudaeShowDisabledIcon', JSON.stringify(showDisabledIcon));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedSeries = localStorage.getItem('mudaeSeriesData');
                const savedNotes = localStorage.getItem('mudaeQuickNotes');
                const savedShowDeselected = localStorage.getItem('mudaeShowDeselected');

                if (savedSeries) {
                    seriesData = JSON.parse(savedSeries);
                    displaySeries();
                    updateStats();
                    document.getElementById('generateBtn').disabled = Object.keys(seriesData).length === 0;
                    document.getElementById('generateColorBtn').disabled = Object.keys(seriesData).length === 0;
                    document.getElementById('playerStatsBtn').disabled = Object.keys(seriesData).length === 0;
                }

                if (savedNotes) {
                    quickNotes = JSON.parse(savedNotes);
                    displayQuickNotes();
                }

                const savedColumns = localStorage.getItem('mudaeGridColumns');
                if (savedColumns) {
                    changeGridColumns(parseInt(savedColumns, 10));
                } else {
                    changeGridColumns(3);
                }

                const savedRankingState = localStorage.getItem('mudaeRankingEnabled');
                if (savedRankingState !== null) {
                    toggleRanking(JSON.parse(savedRankingState));
                }

                if (savedShowDeselected !== null) {
                    toggleDeselectedVisibility(JSON.parse(savedShowDeselected));
                }

                const savedShowDisabledIcon = localStorage.getItem('mudaeShowDisabledIcon');
                if (savedShowDisabledIcon !== null) {
                    toggleDisabledIconVisibility(JSON.parse(savedShowDisabledIcon));
                } else {
                    toggleDisabledIconVisibility(true);
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
        }
        function showPlayerStats() {
            const playerStats = {};
            const defaultOwner = "Unassigned";

            for (const seriesName in seriesData) {
                seriesData[seriesName].characters.forEach(char => {
                    const owner = char.owner ? char.owner : defaultOwner;

                    if (!playerStats[owner]) {
                        playerStats[owner] = {
                            total: 0,
                            animanga: 0,
                            game: 0,
                            both: 0,
                            neither: 0,
                            waifu: 0,
                            husbando: 0,
                            genderBoth: 0,
                            genderNeither: 0
                        };
                    }

                    playerStats[owner].total++;

                    const roulettes = new Set();
                    const genders = new Set();

                    if (char.mudaeTags) {
                        char.mudaeTags.forEach(tag => {
                            if (tag.length > 1) {
                                const roulette = tag[1].toLowerCase();
                                if (roulette === 'a' || roulette === 'g') roulettes.add(roulette);
                            }
                            const gender = tag[0].toLowerCase();
                            if (gender === 'w' || gender === 'h') genders.add(gender);
                        });
                    }

                    const hasAnimanga = roulettes.has('a');
                    const hasGame = roulettes.has('g');
                    const hasWaifu = genders.has('w');
                    const hasHusbando = genders.has('h');

                    if (hasAnimanga && hasGame) playerStats[owner].both++;
                    else if (hasAnimanga) playerStats[owner].animanga++;
                    else if (hasGame) playerStats[owner].game++;
                    else playerStats[owner].neither++;

                    if (hasWaifu && hasHusbando) playerStats[owner].genderBoth++;
                    else if (hasWaifu) playerStats[owner].waifu++;
                    else if (hasHusbando) playerStats[owner].husbando++;
                    else playerStats[owner].genderNeither++;
                });
            }

            const players = Object.keys(playerStats);
            if (players.length === 0) {
                showMessage('No character data found to display stats.', 'error');
                return;
            }

            const colors = ['#a78bfa', '#4ade80', '#fb923c', '#38bdf8', '#f472b6', '#fbbf24', '#ec4899', '#8b5cf6'];

            document.getElementById('seriesGrid').style.display = 'none';
            document.getElementById('commands').style.display = 'none';

            const section = document.getElementById('playerStatsSection');
            section.style.display = 'block';

            let svg = `<svg class="compass-svg" viewBox="-50 -50 700 700" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                
                <rect x="50" y="50" width="500" height="500" fill="none" stroke="#7c3aed" stroke-width="1"/>
                                
                <line x1="300" y1="50" x2="300" y2="550" stroke="#2a2a3a" stroke-width="2"/>
                <line x1="50" y1="300" x2="550" y2="300" stroke="#2a2a3a" stroke-width="2"/>
                
                <line x1="50" y1="175" x2="550" y2="175" stroke="#2a2a3a" stroke-width="1" opacity="0.8" stroke-dasharray="5,5"/>
                <line x1="50" y1="425" x2="550" y2="425" stroke="#2a2a3a" stroke-width="1" opacity="0.8" stroke-dasharray="5,5"/>
                <line x1="175" y1="50" x2="175" y2="550" stroke="#2a2a3a" stroke-width="1" opacity="0.8" stroke-dasharray="5,5"/>
                <line x1="425" y1="50" x2="425" y2="550" stroke="#2a2a3a" stroke-width="1" opacity="0.8" stroke-dasharray="5,5"/>
                
                <text x="300" y="30" text-anchor="middle" fill="#a78bfa" font-size="16" font-weight="bold">Animanga</text>
                <text x="300" y="585" text-anchor="middle" fill="#ffcb70" font-size="16" font-weight="bold">Game</text>
                <text x="25" y="305" text-anchor="middle" fill="#ff8f8f" font-size="16" font-weight="bold">Waifu</text>
                <text x="575" y="305" text-anchor="middle" fill="#8fafff" font-size="16" font-weight="bold">Husbando</text>
            `;

            let legendHTML = '';

            players.forEach((player, idx) => {
                const stats = playerStats[player];
                // Use grey for Unassigned, otherwise cycle colors
                let color;
                if (player === defaultOwner) {
                    color = '#6b7280';
                } else {
                    color = colors[idx % colors.length];
                }

                const animangaCount = stats.animanga + (stats.both * 0.5);
                const gameCount = stats.game + (stats.both * 0.5);
                const waifuCount = stats.waifu + (stats.genderBoth * 0.5);
                const husbandoCount = stats.husbando + (stats.genderBoth * 0.5);

                const animangaPct = stats.total > 0 ? animangaCount / stats.total : 0;
                const gamePct = stats.total > 0 ? gameCount / stats.total : 0;
                const waifuPct = stats.total > 0 ? waifuCount / stats.total : 0;
                const husbandoPct = stats.total > 0 ? husbandoCount / stats.total : 0;

                const y = 300 - (animangaPct * 250) + (gamePct * 250);
                const x = 300 - (waifuPct * 250) + (husbandoPct * 250);

                svg += `<circle cx="${x}" cy="${y}" r="8" fill="${color}" stroke="white" stroke-width="2" filter="url(#glow)"/>`;
                svg += `<text x="${x}" y="${y - 15}" text-anchor="middle" fill="${color}" font-size="14" font-weight="bold" filter="url(#glow)">${player}</text>`;

                legendHTML += `<div class="legend-item">
                    <div class="legend-color" style="background-color: ${color};"></div>
                    <div>
                        <div class="legend-name">${player}</div>
                        <div class="legend-stats">A: ${(animangaPct * 100).toFixed(1)}% | G: ${(gamePct * 100).toFixed(1)}% | W: ${(waifuPct * 100).toFixed(1)}% | H: ${(husbandoPct * 100).toFixed(1)}%</div>
                    </div>
                </div>`;
            });

            svg += `</svg>`;

            section.innerHTML = `
                <div class="stats-compass-container">
                    <h2 class="stats-compass-title">Player Compass</h2>
                    <div class="compass-wrapper">
                        ${svg}
                    </div>
                    <div class="player-legend">
                        ${legendHTML}
                    </div>
                    <button onclick="hidePlayerStats()" class="back-button btn btn-primary">Back to Characters</button>
                </div>
            `;

            section.scrollIntoView({ behavior: 'smooth' });
        }

        function hidePlayerStats() {
            document.getElementById('playerStatsSection').style.display = 'none';
            document.getElementById('seriesGrid').style.display = '';
            document.getElementById('commands').style.display = '';
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function loadDemoData() {
            const inputField = document.getElementById('input');

            if (inputField.value.trim() !== "" && !confirm("This will overwrite your current input. Continue?")) {
                return;
            }

            const demoText = inputField.getAttribute('placeholder');

            inputField.value = demoText;
        }
    </script>
</body>

</html>